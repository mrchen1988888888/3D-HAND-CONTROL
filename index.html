<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dr. Strange: Dual Hand Control</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: monospace; }
        
        /* 1. 视频层 (半透明可见) */
        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; transform: scaleX(-1); object-fit: cover;
            opacity: 0.3; /* 让你可以看到自己 */
        }

        /* 2. 骨架绘制层 (调试用) */
        #debug-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none; transform: scaleX(-1);
        }

        /* 3. 3D 特效层 (最上层) */
        #gl-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 3; pointer-events: none;
        }

        /* HUD & UI */
        #hud {
            position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 10;
        }
        .status {
            background: rgba(0, 0, 0, 0.8); color: #00ff88; padding: 10px 25px; 
            border: 1px solid #00ff88; font-size: 16px; font-weight: bold; display: inline-block;
            border-radius: 20px; text-transform: uppercase;
        }

        #start-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 999; padding: 20px 50px; font-size: 24px; font-weight: bold;
            background: #ffaa00; color: #000; border: 4px solid white; border-radius: 15px;
            cursor: pointer; box-shadow: 0 0 30px #ffaa00;
        }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 800; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .spinner { width: 40px; height: 40px; border: 3px solid #333; border-top: 3px solid #ffaa00; border-radius: 50%; animation: spin 1s infinite linear; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>
    <canvas id="debug-canvas"></canvas> <!-- 用于画手骨架 -->
    
    <div id="loader">
        <div class="spinner"></div>
        <div style="color:#ffaa00; margin-top:15px;">INITIALIZING AI...</div>
    </div>

    <button id="start-btn" onclick="init()">START SYSTEM</button>

    <div id="hud"><div class="status" id="status">STANDBY</div></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script> <!-- 画骨架工具 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. SETUP ---
        const videoElement = document.getElementById('input-video');
        const debugCanvas = document.getElementById('debug-canvas');
        const debugCtx = debugCanvas.getContext('2d');
        const statusText = document.getElementById('status');
        
        // --- 2. VISUAL ENGINE (Cinematic Physics) ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.05); // Dark fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 14;

        const renderer = new THREE.WebGLRenderer({alpha: true, antialias: false});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = 'gl-canvas';
        document.body.appendChild(renderer.domElement);

        // -- Texture (White Hot Spark) --
        const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
        const ctx = cvs.getContext('2d');
        const gr = ctx.createRadialGradient(16,16,0,16,16,16);
        gr.addColorStop(0,'#ffffff'); gr.addColorStop(0.2,'#ffaa00'); gr.addColorStop(0.5,'#ff4400'); gr.addColorStop(1,'transparent');
        ctx.fillStyle=gr; ctx.fillRect(0,0,32,32);
        const tex = new THREE.CanvasTexture(cvs);

        // -- Particle System --
        const COUNT = 6000; // High density
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(COUNT*3);
        const col = new Float32Array(COUNT*3);
        const vel = new Float32Array(COUNT*3); // Store velocity
        const life = new Float32Array(COUNT);  // Store life
        const maxLife = new Float32Array(COUNT);

        for(let i=0; i<COUNT; i++) {
            pos[i*3]=9999; life[i]=0; 
        }
        
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        geo.setAttribute('color', new THREE.BufferAttribute(col,3));

        const mat = new THREE.PointsMaterial({
            size: 0.35, map: tex, transparent: true, opacity: 1,
            vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const sys = new THREE.Points(geo, mat);
        scene.add(sys);

        // -- The Void --
        const voidGeo = new THREE.CircleGeometry(1, 64);
        const voidMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const portalVoid = new THREE.Mesh(voidGeo, voidMat);
        portalVoid.position.z = 0.1;
        scene.add(portalVoid);

        // --- 3. LOGIC ---
        let State = { r:0, tr:0 };

        function resetParticle(i) {
            const idx = i*3;
            // Only spawn if radius is open
            if(State.r > 0.2) {
                const angle = Math.random() * Math.PI * 2;
                const r = State.r + (Math.random()-0.5)*0.2; // Spawn on ring

                pos[idx] = Math.cos(angle) * r;
                pos[idx+1] = Math.sin(angle) * r;
                pos[idx+2] = (Math.random()-0.5)*0.5;

                // TANGENTIAL VELOCITY (The "Buzzsaw" Look)
                // Tangent vector is (-y, x)
                const speed = 0.15 + Math.random()*0.2;
                vel[idx] = -Math.sin(angle)*speed + (Math.random()-0.5)*0.05; 
                vel[idx+1] = Math.cos(angle)*speed + (Math.random()-0.5)*0.05;
                vel[idx+2] = (Math.random()-0.5)*0.02;

                life[i] = 1.0;
                maxLife[i] = 0.5 + Math.random()*0.5;
            } else {
                pos[idx] = 9999;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth Radius Transition
            State.r += (State.tr - State.r) * 0.1;
            
            // Visuals
            portalVoid.scale.setScalar(Math.max(0.01, State.r * 0.9));
            sys.rotation.z -= 0.02; // Spin the whole system

            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                life[i] -= 0.02; // Decay

                if(life[i] <= 0) {
                    resetParticle(i);
                } else {
                    // Move
                    pos[idx] += vel[idx];
                    pos[idx+1] += vel[idx+1];
                    pos[idx+2] += vel[idx+2];

                    // Color Gradient (White -> Gold -> Red)
                    const l = life[i];
                    if(l > 0.8) { col[idx]=1; col[idx+1]=1; col[idx+2]=1; } // White
                    else if(l > 0.5) { col[idx]=1; col[idx+1]=0.8; col[idx+2]=0.2; } // Gold
                    else { col[idx]=1; col[idx+1]=0.2; col[idx+2]=0; } // Red
                }
            }
            
            geo.attributes.position.needsUpdate = true;
            geo.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 4. AI & GESTURES ---
        async function init() {
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('loader').style.display = 'flex';

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            // IMPORTANT: Detect 2 Hands for distance check
            hands.setOptions({
                maxNumHands: 2, 
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            const cam = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 640, height: 480, facingMode: 'user'
            });
            await cam.start();
            
            document.getElementById('loader').style.display = 'none';
            resizeCanvas();
        }

        function onResults(results) {
            // 1. Draw Debug Skeleton
            debugCtx.save();
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(debugCtx, landmarks, HAND_CONNECTIONS, {color: '#00ff88', lineWidth: 2});
                    drawLandmarks(debugCtx, landmarks, {color: '#ff0000', lineWidth: 1, radius: 3});
                }
            }
            debugCtx.restore();

            // 2. Control Logic (Dual Hand Distance)
            if (results.multiHandLandmarks.length === 2) {
                // Get Wrists of both hands
                const hand1 = results.multiHandLandmarks[0][0]; // Landmark 0 is wrist
                const hand2 = results.multiHandLandmarks[1][0];

                // Calculate distance (0.0 to ~0.8)
                const dist = Math.hypot(hand1.x - hand2.x, hand1.y - hand2.y);
                
                // Map distance to Radius
                // Close hands (dist < 0.2) -> Closed
                // Far hands (dist > 0.6) -> Fully Open (Radius 5.5)
                const minD = 0.15;
                const maxD = 0.6;
                
                const normalized = Math.max(0, Math.min(1, (dist - minD) / (maxD - minD)));
                State.tr = normalized * 5.5;

                statusText.innerText = `DISTANCE: ${(normalized*100).toFixed(0)}%`;
                statusText.style.color = "#ffaa00";
                statusText.style.borderColor = "#ffaa00";

            } else if (results.multiHandLandmarks.length === 1) {
                statusText.innerText = "NEED 2 HANDS";
                statusText.style.color = "#fff";
                statusText.style.borderColor = "#fff";
                State.tr = 0; // Close if only 1 hand
            } else {
                statusText.innerText = "NO HANDS DETECTED";
                statusText.style.color = "#555";
                statusText.style.borderColor = "#555";
                State.tr = 0;
            }
        }

        function resizeCanvas() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            debugCanvas.width = window.innerWidth;
            debugCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>

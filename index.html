<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>2025 æ–°å¹´ç²’å­(æé€Ÿç‰ˆ)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #1a0505; font-family: 'Segoe UI', sans-serif; }
        
        body { background: radial-gradient(circle, #2b0a0a 0%, #000000 100%); }

        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            opacity: 0; pointer-events: none; z-index: -1; 
            transform: scaleX(-1);
        }
        
        #title-display {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            font-size: 24px; font-weight: bold; color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            pointer-events: none; z-index: 90;
            text-align: center; letter-spacing: 2px;
            width: 100%;
        }

        #guide-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(40, 0, 0, 0.6); border: 1px solid #ff4444;
            padding: 10px 20px; border-radius: 30px;
            color: #ffcccc; font-size: 13px;
            pointer-events: none; z-index: 90; text-align: center;
            white-space: nowrap;
        }

        /* çŠ¶æ€æŒ‡ç¤ºæ”¹æˆå·¦ä¸Šè§’å°å­—ï¼Œä¸é®æŒ¡è§†çº¿ */
        #hud-status {
            position: absolute; top: 80px; left: 20px;
            font-size: 12px; color: #888;
            font-family: monospace;
            z-index: 50;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }

        /* åŠ è½½å±‚æ ·å¼ä¼˜åŒ– */
        .loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200;
            transition: opacity 0.5s;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #ffd700; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loading" class="loading-mask">
        <div class="spinner"></div>
        <div id="loading-text" style="color:#ffd700; font-size: 14px;">èµ„æºåŠ è½½ä¸­...</div>
    </div>
    
    <div id="title-display">HAPPY NEW YEAR 2025</div>
    <div id="hud-status">AI ç³»ç»Ÿ: åˆå§‹åŒ–ä¸­...</div>
    
    <div id="guide-panel">
        ğŸ–±ï¸ ç‚¹å‡»æ•°å­—äº’åŠ¨ | ğŸ‘Œ OKæ‰‹åŠ¿å¤ä½
    </div>

    <!-- ä¾ç„¶ä½¿ç”¨å›½å†…æº -->
    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- é”™è¯¯å¤„ç†ä¸åŠ è½½æ§åˆ¶ ---
        const loadingMask = document.getElementById('loading');
        const loadText = document.getElementById('loading-text');
        
        // å¼ºåˆ¶ 3ç§’åæ— è®ºå¦‚ä½•éƒ½éšè—åŠ è½½å±‚ï¼Œä¿è¯ç”¨æˆ·èƒ½çœ‹åˆ°ç”»é¢
        setTimeout(() => {
            if(loadingMask.style.display !== 'none') {
                loadingMask.style.opacity = '0';
                setTimeout(()=> loadingMask.style.display = 'none', 500);
            }
        }, 2000);

        // --- 1. Three.js åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a0505, 0.002);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // --- 2. æ•°å­—ç²’å­ç”Ÿæˆ (Canvasæ³•) ---
        const digitMeshes = [];
        const digitData = [
            { char: "2", x: -9 }, { char: "0", x: -3 }, { char: "2", x: 3 }, { char: "5", x: 9 }
        ];

        const targets = {
            center: new THREE.Vector3(0, 0, 10)
        };
        let activeDigitIndex = -1;

        function createTextParticles(text, offsetX) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200; canvas.height = 200;
            ctx.font = 'bold 160px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 100);

            const imgData = ctx.getImageData(0, 0, 200, 200);
            const positions = [];
            for (let y = 0; y < 200; y += 4) {
                for (let x = 0; x < 200; x += 4) {
                    if (imgData.data[(y * 200 + x) * 4] > 128) {
                        positions.push((x - 100) * 0.1, (100 - y) * 0.1, (Math.random() - 0.5) * 2);
                    }
                }
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffd700, size: 0.25, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });
            const mesh = new THREE.Points(geometry, material);
            mesh.position.set(offsetX, 0, 0);
            mesh.userData = { originalPos: new THREE.Vector3(offsetX, 0, 0) };
            scene.add(mesh);
            return mesh;
        }

        // ç”Ÿæˆæ•°å­—
        digitData.forEach(d => digitMeshes.push(createTextParticles(d.char, d.x)));

        // æ‰‹åŠ¨éšè—åŠ è½½å±‚ (3Dåˆ›å»ºå®Œæ¯•)
        loadText.innerText = "å¯åŠ¨è§†è§‰ç³»ç»Ÿ...";
        setTimeout(() => {
             loadingMask.style.opacity = '0';
             setTimeout(()=> loadingMask.style.display = 'none', 500);
        }, 500);

        // --- 3. äº¤äº’é€»è¾‘ ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        raycaster.params.Points.threshold = 1.0;

        function handleInput(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(digitMeshes);
            if (intersects.length > 0) {
                const index = digitMeshes.indexOf(intersects[0].object);
                if (index !== -1 && index !== activeDigitIndex) {
                    activeDigitIndex = index;
                    document.getElementById('hud-status').innerText = `é€‰ä¸­æ•°å­—: ${digitData[index].char}`;
                    document.getElementById('hud-status').style.color = "#ffdd00";
                }
            } else {
                 // ç‚¹å‡»ç©ºç™½å¤„å¤ä½ (å¯é€‰)
                 // resetAll();
            }
        }

        window.addEventListener('click', e => handleInput(e.clientX, e.clientY));
        window.addEventListener('touchstart', e => {
            e.preventDefault();
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        function resetAll() {
            if (activeDigitIndex === -1) return;
            activeDigitIndex = -1;
            document.getElementById('hud-status').innerText = "ç³»ç»Ÿå°±ç»ª (ç­‰å¾…æ‰‹åŠ¿)";
            document.getElementById('hud-status').style.color = "#888";
        }

        // --- 4. åŠ¨ç”» ---
        function animate() {
            requestAnimationFrame(animate);
            digitMeshes.forEach((mesh, i) => {
                mesh.rotation.y += 0.005;
                let targetPos, targetScale, targetOpacity;
                
                if (activeDigitIndex === -1) {
                    targetPos = mesh.userData.originalPos;
                    targetScale = 1.0; targetOpacity = 0.9;
                } else {
                    if (i === activeDigitIndex) {
                        targetPos = targets.center;
                        targetScale = 2.0; targetOpacity = 1.0;
                    } else {
                        // æ²¡è¢«é€‰ä¸­çš„ï¼Œå‘ä¸¤è¾¹æ•£å¼€
                        targetPos = mesh.userData.originalPos.clone().multiplyScalar(5); 
                        targetScale = 0.1; targetOpacity = 0.0;
                    }
                }
                mesh.position.lerp(targetPos, 0.08);
                const s = mesh.scale.x + (targetScale - mesh.scale.x) * 0.08;
                mesh.scale.set(s,s,s);
                mesh.material.opacity += (targetOpacity - mesh.material.opacity) * 0.1;
                mesh.material.size = (targetScale > 1.5 ? 0.35 : 0.25);
            });
            renderer.render(scene, camera);
        }
        animate();

        // --- 5. AI æ‰‹åŠ¿ (åå°é™é»˜åŠ è½½) ---
        const videoElement = document.getElementById('input-video');
        const hudStatus = document.getElementById('hud-status');
        let lastOkTime = 0;

        const hands = new Hands({locateFile: (file) => `https://npm.elemecdn.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        hands.onResults((results) => {
            // åªè¦æ‰‹åŠ¿å¼€å§‹å·¥ä½œï¼Œæ›´æ–°çŠ¶æ€
            if (hudStatus.innerText.includes("åˆå§‹åŒ–")) hudStatus.innerText = "AI è§†è§‰å·²å¯åŠ¨";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                // OKæ‰‹åŠ¿æ£€æµ‹
                const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y) / Math.hypot(lm[0].x-lm[9].x, lm[0].y-lm[9].y) < 0.25;
                const threeUp = lm[12].y < lm[2].y && lm[16].y < lm[2].y && lm[20].y < lm[2].y;
                
                if (pinch && threeUp) {
                    const now = Date.now();
                    if (now - lastOkTime > 1000) {
                        resetAll();
                        hudStatus.innerText = "ğŸ‘Œ å¤ä½æŒ‡ä»¤å·²ç¡®è®¤";
                        hudStatus.style.color = "#00ff88";
                        lastOkTime = now;
                    }
                }
            }
        });

        // å¯åŠ¨æ‘„åƒå¤´ (é™é»˜å¯åŠ¨ï¼Œä¸é˜»å¡ç”»é¢)
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 480, height: 360, facingMode: 'user'
        });
        
        cameraUtils.start().catch(e => {
            hudStatus.innerText = "âš ï¸ æ‘„åƒå¤´æœªæˆæƒ (ä»…ç‚¹å‡»æ¨¡å¼)";
            console.log(e);
        });

        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        });
    </script>
</body>
</html>

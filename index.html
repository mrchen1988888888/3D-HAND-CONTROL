<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dr. Strange: Ultimate Dual Hand</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: monospace; }
        
        /* 1. 视频层 (底层，半透明) */
        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; transform: scaleX(-1); object-fit: cover;
            opacity: 0.3; 
        }

        /* 2. 骨架调试层 (中间层) */
        #debug-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none; transform: scaleX(-1);
        }

        /* 3. 3D 特效层 (最上层) */
        #gl-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }

        /* HUD */
        #hud { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 20; pointer-events: none; }
        .status {
            background: rgba(0, 0, 0, 0.8); color: #ffaa00; padding: 10px 25px; 
            border: 2px solid #ffaa00; font-size: 18px; font-weight: bold; border-radius: 20px;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
        }

        #start-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 100; padding: 20px 50px; font-size: 24px; font-weight: bold;
            background: #ffaa00; color: #000; border: 4px solid white; border-radius: 15px;
            cursor: pointer; box-shadow: 0 0 30px #ffaa00;
        }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 90; display: none;
            justify-content: center; align-items: center; color: #ffaa00;
        }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>
    <canvas id="debug-canvas"></canvas>
    
    <div id="loader">INITIALIZING PHYSICS ENGINE...</div>
    <button id="start-btn" onclick="init()">START SYSTEM</button>
    <div id="hud"><div class="status" id="status">STANDBY</div></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const videoElement = document.getElementById('input-video');
        const debugCanvas = document.getElementById('debug-canvas');
        const debugCtx = debugCanvas.getContext('2d');
        const statusText = document.getElementById('status');
        
        // --- 1. VISUAL ENGINE (Cinematic Physics) ---
        const scene = new THREE.Scene();
        // Dark fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.03); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 14;

        const renderer = new THREE.WebGLRenderer({alpha: true, antialias: false});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = 'gl-canvas';
        document.body.appendChild(renderer.domElement);

        // -- Texture Generation (Hot Spark) --
        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
        const ctx = cvs.getContext('2d');
        const gr = ctx.createRadialGradient(32,32,0,32,32,32);
        gr.addColorStop(0,'#ffffff');   // Core White
        gr.addColorStop(0.2,'#ffaa00'); // Inner Gold
        gr.addColorStop(0.5,'#ff4400'); // Outer Red
        gr.addColorStop(1,'transparent');
        ctx.fillStyle=gr; ctx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(cvs);

        // -- Physics Particle System --
        const COUNT = 5000;
        const geo = new THREE.BufferGeometry();
        
        const pos = new Float32Array(COUNT*3);
        const col = new Float32Array(COUNT*3);
        
        // Physics Data Arrays
        const vel = new Float32Array(COUNT*3); // Velocity Vector
        const life = new Float32Array(COUNT);  // Life (0.0 - 1.0)

        for(let i=0; i<COUNT; i++) { 
            pos[i*3]=9999; // Hide initially
            life[i]=0; 
        }
        
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        geo.setAttribute('color', new THREE.BufferAttribute(col,3));

        const mat = new THREE.PointsMaterial({
            size: 1.2, // Big enough for iPad visibility
            map: tex, 
            transparent: true, 
            opacity: 1,
            vertexColors: true, 
            blending: THREE.AdditiveBlending, // Glow effect
            depthWrite: false
        });
        const sys = new THREE.Points(geo, mat);
        sys.position.z = 0.5; // In front of void
        scene.add(sys);

        // -- The Void (Black Hole) --
        const voidGeo = new THREE.CircleGeometry(1, 64);
        const voidMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const portalVoid = new THREE.Mesh(voidGeo, voidMat);
        portalVoid.position.z = 0;
        scene.add(portalVoid);

        // --- 2. LOGIC ---
        let State = { 
            r: 0,       // Current Radius
            tr: 0,      // Target Radius
            maxR: 6.5   // Max Size
        };

        function resetParticle(i) {
            const idx = i*3;
            
            // Only spawn if portal is open
            if(State.r > 0.3) {
                const angle = Math.random() * 6.28; // Random angle 0-360
                
                // Spawn position: On the ring edge + slight jitter
                const r = State.r + (Math.random()-0.5)*0.3;

                pos[idx] = Math.cos(angle) * r;
                pos[idx+1] = Math.sin(angle) * r;
                pos[idx+2] = (Math.random()-0.5)*0.5; // Z depth

                // TANGENTIAL VELOCITY (The key to the look)
                // Vector (-y, x) is tangent to circle
                const speed = 0.15 + Math.random()*0.2;
                
                // Add velocity outwards + tangential
                vel[idx] = -Math.sin(angle)*speed + (Math.random()-0.5)*0.05; 
                vel[idx+1] = Math.cos(angle)*speed + (Math.random()-0.5)*0.05;
                vel[idx+2] = (Math.random()-0.5)*0.02;

                life[i] = 1.0; // Reset life
            } else {
                pos[idx] = 9999; // Hide
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Physics Smoothing
            State.r += (State.tr - State.r) * 0.1;
            
            // Visual Updates
            portalVoid.scale.setScalar(Math.max(0.01, State.r * 0.85));
            sys.rotation.z -= 0.03; // Rotate whole system

            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                life[i] -= 0.02; // Decay

                if(life[i] <= 0) {
                    resetParticle(i);
                } else {
                    // Move Particle
                    pos[idx] += vel[idx];
                    pos[idx+1] += vel[idx+1];
                    pos[idx+2] += vel[idx+2];

                    // Color Gradient Logic
                    const l = life[i];
                    if(l > 0.8) { col[idx]=1; col[idx+1]=1; col[idx+2]=1; } // White
                    else if(l > 0.5) { col[idx]=1; col[idx+1]=0.8; col[idx+2]=0.1; } // Gold
                    else { col[idx]=1; col[idx+1]=0.2; col[idx+2]=0; } // Red
                }
            }
            
            geo.attributes.position.needsUpdate = true;
            geo.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 3. AI & GESTURES ---
        async function init() {
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('loader').style.display = 'flex';

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 2, 
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            const cam = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 640, height: 480, facingMode: 'user'
            });
            await cam.start();
            
            document.getElementById('loader').style.display = 'none';
            resizeCanvas();
        }

        function onResults(results) {
            // Draw Skeleton
            debugCtx.save();
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(debugCtx, landmarks, HAND_CONNECTIONS, {color: '#00ff88', lineWidth: 2});
                    drawLandmarks(debugCtx, landmarks, {color: '#ff0000', lineWidth: 1, radius: 4});
                }
            }
            debugCtx.restore();

            // Distance Logic
            if (results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0][0]; // Wrist 1
                const h2 = results.multiHandLandmarks[1][0]; // Wrist 2
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                
                // Map Distance (0.15 - 0.6) to Size (0 - 1)
                let openAmt = (dist - 0.15) * 2.5; 
                openAmt = Math.max(0, Math.min(1, openAmt));
                
                State.tr = openAmt * State.maxR;

                statusText.innerText = `POWER: ${(openAmt*100).toFixed(0)}%`;
                statusText.style.color = "#ffaa00";
                
            } else {
                State.tr = 0;
                statusText.innerText = "WAITING FOR 2 HANDS";
                statusText.style.color = "#fff";
            }
        }

        function resizeCanvas() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            debugCanvas.width = window.innerWidth;
            debugCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>

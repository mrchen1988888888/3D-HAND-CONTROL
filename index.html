<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>奇异博士传送门(防抖稳定版)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #input-video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; transform: scaleX(-1); }
        
        #hud { position: absolute; bottom: 50px; width: 100%; text-align: center; z-index: 10; pointer-events: none; }
        .title { color: #f5a623; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px rgba(245, 166, 35, 0.8); margin-bottom: 10px; }
        .status { color: #ddd; background: rgba(0,0,0,0.6); padding: 8px 20px; border-radius: 20px; display: inline-block; font-size: 16px; border: 1px solid rgba(255,255,255,0.1); transition: color 0.3s; }

        #energy-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; pointer-events: none; opacity: 0.8; z-index: 5; }
        
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loading">
        <div style="color:#f5a623; font-size: 20px; font-weight:bold;">⚡ 正在构建魔法矩阵...</div>
        <div style="color:#00ff88; margin-top:10px; font-size:12px;">使用国内极速节点</div>
    </div>

    <div id="hud">
        <div class="title">SLING RING</div>
        <div class="status" id="status-text">举起食指 顺时针画圈</div>
    </div>

    <div id="energy-container">
        <svg width="200" height="200" viewBox="0 0 200 200">
            <circle cx="100" cy="100" r="40" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2" />
            <circle id="ring" cx="100" cy="100" r="40" fill="none" stroke="#f5a623" stroke-width="4" stroke-dasharray="251" stroke-dashoffset="251" transform="rotate(-90 100 100)" stroke-linecap="round" />
        </svg>
    </div>

    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        const renderer = new THREE.WebGLRenderer({antialias:false});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        const canvas = document.createElement('canvas');
        canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32,32,0,32,32,32);
        grad.addColorStop(0,'white'); grad.addColorStop(0.2,'#ffc800'); grad.addColorStop(0.4,'#ff6400'); grad.addColorStop(1,'transparent');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        const texture = new THREE.CanvasTexture(canvas);

        const count = 2500;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count*3);
        const speeds = new Float32Array(count);
        const angles = new Float32Array(count);
        const radii = new Float32Array(count);
        
        for(let i=0; i<count; i++) {
            angles[i] = Math.random()*Math.PI*2;
            radii[i] = (Math.random()-0.5)*1.5;
            speeds[i] = 2+Math.random()*3;
            pos[i*3]=999; pos[i*3+1]=999; pos[i*3+2]=0;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        const mat = new THREE.PointsMaterial({size:0.4, map:texture, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false});
        const ring = new THREE.Points(geo, mat);
        scene.add(ring);

        const mirror = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1,2),
            new THREE.MeshBasicMaterial({color:0x001133, wireframe:true, transparent:true, opacity:0})
        );
        scene.add(mirror);

        let state = { r:0, targetR:0, progress:0 };

        function animate() {
            requestAnimationFrame(animate);
            state.r += (state.targetR - state.r)*0.08; // 平滑插值
            mirror.scale.setScalar(state.r*0.9);
            mirror.material.opacity = Math.min(1, state.r/3);
            mirror.rotation.y += 0.01;
            
            ring.rotation.z -= 0.03;
            const p = ring.geometry.attributes.position.array;
            for(let i=0; i<count; i++) {
                angles[i] += speeds[i]*0.01;
                const r = state.r + radii[i];
                if(state.r > 0.1) {
                    p[i*3] = Math.cos(angles[i])*r + (Math.random()-0.5)*0.15;
                    p[i*3+1] = Math.sin(angles[i])*r + (Math.random()-0.5)*0.15;
                    p[i*3+2] = (Math.random()-0.5);
                } else { p[i*3]=999; }
            }
            ring.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        const video = document.getElementById('input-video');
        const uiRing = document.getElementById('ring');
        const uiText = document.getElementById('status-text');
        let lastAng = null;
        let lossCounter = 0; // 信号丢失计数器

        const hands = new Hands({locateFile: (file) => `https://npm.elemecdn.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        let loaded = false;
        hands.onResults(res => {
            if(!loaded) { loaded = true; document.getElementById('loading').style.display = 'none'; }
            
            if(res.multiHandLandmarks.length > 0) {
                // 成功检测到手
                lossCounter = 0; // 重置丢失计数
                
                const lm = res.multiHandLandmarks[0];
                const tip = lm[8];
                const ang = Math.atan2(tip.y-0.5, tip.x-0.5);
                
                if(lastAng !== null) {
                    let d = ang - lastAng;
                    if(d > Math.PI) d -= Math.PI*2;
                    if(d < -Math.PI) d += Math.PI*2;
                    if(Math.abs(d) < 0.5) state.progress += d * 2.5; // 增加灵敏度
                }
                lastAng = ang;
                state.progress = Math.max(0, Math.min(state.progress, Math.PI*4));
                const ratio = state.progress / (Math.PI*4);
                
                // 只有当持续有信号时才更新半径
                state.targetR = ratio * 6;
                uiRing.style.strokeDashoffset = 251 - (251*ratio);
                
                if(ratio > 0.8) { uiText.innerText = "传送门已稳定 (OPEN)"; uiText.style.color="#0f8"; }
                else if(ratio > 0.1) { uiText.innerText = `能量汇聚中 ${(ratio*100).toFixed(0)}%`; uiText.style.color="#f80"; }
                else { uiText.innerText = "检测到手部 - 请画圈"; uiText.style.color="#fff"; }

            } else {
                // 未检测到手 (防抖逻辑)
                lossCounter++;
                
                // 只有连续丢帧超过 15帧 (约0.5秒) 才认为真正丢失
                if (lossCounter > 15) {
                    lastAng = null;
                    state.targetR = 0;
                    state.progress *= 0.92; // 缓慢消散
                    uiText.innerText = "信号丢失 (请调整光线或距离)"; 
                    uiText.style.color="#555";
                }
            }
        });

        const cam = new Camera(video, {
            onFrame: async () => await hands.send({image: video}),
            width: 640, height: 480, facingMode: 'user'
        });
        cam.start();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>

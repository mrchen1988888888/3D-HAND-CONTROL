<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>é­”æ³•ä¼ é€é—¨(å¤šçº¿è·¯ç‰ˆ)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #input-video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; transform: scaleX(-1); }
        
        /* åŠ è½½å±‚ & çº¿è·¯é€‰æ‹©å™¨ */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .spinner { width: 50px; height: 50px; border: 3px solid #333; border-top: 3px solid #f5a623; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        .loading-text { color: #f5a623; font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        .sub-text { color: #666; font-size: 12px; margin-bottom: 30px; }
        
        /* çº¿è·¯æŒ‰é’® */
        .line-selector { display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 300px; }
        .line-btn {
            background: #222; border: 1px solid #444; color: #ccc;
            padding: 12px; border-radius: 8px; font-size: 14px;
            cursor: pointer; transition: all 0.2s;
            display: flex; justify-content: space-between;
        }
        .line-btn:active { background: #444; }
        .line-btn.active { border-color: #f5a623; color: #f5a623; background: rgba(245, 166, 35, 0.1); }
        .line-tag { font-size: 10px; background: #444; padding: 2px 6px; border-radius: 4px; }

        /* HUD */
        #hud { position: absolute; bottom: 50px; width: 100%; text-align: center; z-index: 10; pointer-events: none; display: none; }
        .title { color: #f5a623; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px rgba(245, 166, 35, 0.8); margin-bottom: 10px; }
        .status { color: #ddd; background: rgba(0,0,0,0.6); padding: 8px 20px; border-radius: 20px; display: inline-block; font-size: 16px; border: 1px solid rgba(255,255,255,0.1); }

        #energy-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; pointer-events: none; opacity: 0.8; z-index: 5; display: none; }
        
        #log-area { position: absolute; bottom: 10px; color: #444; font-size: 10px; font-family: monospace; }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loading-screen">
        <div class="spinner"></div>
        <div class="loading-text">æ­£åœ¨åˆå§‹åŒ–...</div>
        <div class="sub-text" id="status-msg">è‹¥å¡ä½è¶…è¿‡10ç§’ï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹åˆ‡æ¢çº¿è·¯</div>
        
        <div class="line-selector">
            <button class="line-btn" onclick="switchLine('eleme')">
                <span>âš¡ çº¿è·¯1: é¥¿äº†ä¹ˆCDN</span> <span class="line-tag">å›½å†…æ¨è</span>
            </button>
            <button class="line-btn" onclick="switchLine('unpkg')">
                <span>ğŸ¢ çº¿è·¯2: Unpkg</span> <span class="line-tag">æ…¢ä½†ç¨³</span>
            </button>
            <button class="line-btn" onclick="switchLine('jsdelivr')">
                <span>ğŸŒ çº¿è·¯3: jsDelivr</span> <span class="line-tag">å¤‡ç”¨</span>
            </button>
        </div>
        <div id="log-area">ç­‰å¾…é€‰æ‹©...</div>
    </div>

    <div id="hud">
        <div class="title">SLING RING</div>
        <div class="status" id="status-text">ä¸¾èµ·é£ŸæŒ‡ é¡ºæ—¶é’ˆç”»åœˆ</div>
    </div>

    <div id="energy-container">
        <svg width="200" height="200" viewBox="0 0 200 200">
            <circle cx="100" cy="100" r="40" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2" />
            <circle id="ring" cx="100" cy="100" r="40" fill="none" stroke="#f5a623" stroke-width="4" stroke-dasharray="251" stroke-dashoffset="251" transform="rotate(-90 100 100)" stroke-linecap="round" />
        </svg>
    </div>

    <!-- åŸºç¡€ Three.js (æ¯”è¾ƒå°ï¼Œé€šå¸¸æ²¡é—®é¢˜) -->
    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>
    
    <!-- MediaPipe åŠ¨æ€åŠ è½½å™¨ -->
    <script>
        // === 1. çº¿è·¯é…ç½® ===
        const CDNS = {
            'eleme': 'https://npm.elemecdn.com/@mediapipe/hands',
            'unpkg': 'https://unpkg.com/@mediapipe/hands',
            'jsdelivr': 'https://cdn.jsdelivr.net/npm/@mediapipe/hands'
        };

        // é»˜è®¤ä½¿ç”¨é¥¿äº†ä¹ˆï¼Œå¦‚æœ URL æœ‰å‚æ•°åˆ™è¦†ç›–
        const urlParams = new URLSearchParams(window.location.search);
        const currentLine = urlParams.get('line') || 'eleme';
        
        // UI æ›´æ–°
        document.querySelectorAll('.line-btn').forEach(btn => {
            if(btn.innerText.toLowerCase().includes(currentLine)) btn.classList.add('active');
        });
        
        function log(msg) { document.getElementById('log-area').innerText = msg; console.log(msg); }
        
        // åˆ‡æ¢çº¿è·¯å‡½æ•°
        window.switchLine = function(lineName) {
            log(`æ­£åœ¨åˆ‡æ¢åˆ° ${lineName}...`);
            // åˆ·æ–°é¡µé¢å¹¶å¸¦ä¸Šå‚æ•°
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('line', lineName);
            window.location.href = newUrl.toString();
        }

        // åŠ¨æ€åŠ è½½è„šæœ¬
        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = resolve;
                script.onerror = reject;
                document.body.appendChild(script);
            });
        }

        // === 2. å¯åŠ¨æµç¨‹ ===
        async function initApp() {
            const baseUrl = CDNS[currentLine];
            log(`æ­£åœ¨ä» [${currentLine}] åŠ è½½æ ¸å¿ƒç»„ä»¶...`);
            
            try {
                // é¡ºåºåŠ è½½ä¾èµ–
                await loadScript(`${baseUrl}/camera_utils.js`);
                await loadScript(`${baseUrl}/control_utils.js`);
                await loadScript(`${baseUrl}/hands.js`);
                
                log("ç»„ä»¶åŠ è½½å®Œæ¯•ï¼Œå¯åŠ¨ AI å¼•æ“...");
                startAI(baseUrl);
                
            } catch (e) {
                log(`âŒ åŠ è½½å¤±è´¥! è¯·å°è¯•åˆ‡æ¢å…¶ä»–çº¿è·¯`);
                document.getElementById('status-msg').innerText = "å½“å‰çº¿è·¯æ— æ³•è¿æ¥ï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ‡æ¢";
                document.getElementById('status-msg').style.color = "red";
            }
        }

        // === 3. ä¸šåŠ¡é€»è¾‘ ===
        function startAI(baseUrl) {
            const video = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => {
                log(`ğŸ“¥ è¯·æ±‚: ${file}`);
                return `${baseUrl}/${file}`;
            }});

            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            let isLoaded = false;
            hands.onResults(onResults);

            const camera = new Camera(video, {
                onFrame: async () => await hands.send({image: video}),
                width: 640, height: 480, facingMode: 'user'
            });

            camera.start()
                .then(() => log("æ‘„åƒå¤´å·²å¼€å¯ï¼Œç­‰å¾… AI å“åº”..."))
                .catch(e => log("âŒ æ‘„åƒå¤´æƒé™è¢«æ‹’ç»ï¼"));

            // ç»“æœå¤„ç†
            function onResults(results) {
                if (!isLoaded) {
                    isLoaded = true;
                    document.getElementById('loading-screen').style.display = 'none';
                    document.getElementById('hud').style.display = 'block';
                    document.getElementById('energy-container').style.display = 'block';
                }
                updateGameLogic(results); // è°ƒç”¨ä¸‹æ–¹çš„æ¸¸æˆé€»è¾‘
            }
        }

        // å¼€å§‹æ‰§è¡Œ
        initApp();

        // ---------------------------------------------------------
        // æ¸¸æˆé€»è¾‘ (Three.js & Interaction)
        // ---------------------------------------------------------
        
        // Three.js Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const cam3d = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        cam3d.position.z = 15;
        const renderer = new THREE.WebGLRenderer({antialias:false});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // Texture
        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
        const ctx = cvs.getContext('2d');
        const gr = ctx.createRadialGradient(32,32,0,32,32,32);
        gr.addColorStop(0,'white'); gr.addColorStop(0.2,'#ffc800'); gr.addColorStop(1,'transparent');
        ctx.fillStyle=gr; ctx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(cvs);

        // Particles
        const count = 2500;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count*3);
        const spd = new Float32Array(count);
        const ang = new Float32Array(count);
        const rad = new Float32Array(count);
        for(let i=0; i<count; i++) {
            ang[i] = Math.random()*Math.PI*2;
            rad[i] = (Math.random()-0.5)*1.5;
            spd[i] = 2+Math.random()*3;
            pos[i*3]=999;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        const mat = new THREE.PointsMaterial({size:0.4, map:tex, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false});
        const ring = new THREE.Points(geo, mat);
        scene.add(ring);

        const mirror = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1,2),
            new THREE.MeshBasicMaterial({color:0x001133, wireframe:true, transparent:true, opacity:0})
        );
        scene.add(mirror);

        let st = { r:0, tr:0, prog:0 };

        function animate() {
            requestAnimationFrame(animate);
            st.r += (st.tr - st.r)*0.08;
            mirror.scale.setScalar(st.r*0.9);
            mirror.material.opacity = Math.min(1, st.r/3);
            mirror.rotation.y+=0.01;
            ring.rotation.z -= 0.03;
            
            const p = ring.geometry.attributes.position.array;
            for(let i=0; i<count; i++) {
                ang[i] += spd[i]*0.01;
                const r = st.r + rad[i];
                if(st.r > 0.1) {
                    p[i*3] = Math.cos(ang[i])*r + (Math.random()-0.5)*0.15;
                    p[i*3+1] = Math.sin(ang[i])*r + (Math.random()-0.5)*0.15;
                    p[i*3+2] = (Math.random()-0.5);
                } else { p[i*3]=999; }
            }
            ring.geometry.attributes.position.needsUpdate=true;
            renderer.render(scene, cam3d);
        }
        animate();

        // äº¤äº’é€»è¾‘
        let lastAng = null;
        let lossCount = 0;
        const uiRing = document.getElementById('ring');
        const uiText = document.getElementById('status-text');

        function updateGameLogic(results) {
            if(results.multiHandLandmarks.length > 0) {
                lossCount = 0;
                const lm = results.multiHandLandmarks[0];
                const tip = lm[8];
                const curAng = Math.atan2(tip.y-0.5, tip.x-0.5);
                
                if(lastAng !== null) {
                    let d = curAng - lastAng;
                    if(d > Math.PI) d -= Math.PI*2;
                    if(d < -Math.PI) d += Math.PI*2;
                    if(Math.abs(d) < 0.5) st.prog += d * 2.5;
                }
                lastAng = curAng;
                st.prog = Math.max(0, Math.min(st.prog, Math.PI*4));
                const ratio = st.prog / (Math.PI*4);
                st.tr = ratio * 6;
                uiRing.style.strokeDashoffset = 251 - (251*ratio);
                
                if(ratio>0.8) { uiText.innerText="ä¼ é€é—¨å¼€å¯"; uiText.style.color="#0f8"; }
                else if(ratio>0.1) { uiText.innerText=`èƒ½é‡ ${(ratio*100).toFixed(0)}%`; uiText.style.color="#f80"; }
                else { uiText.innerText="è¯·é¡ºæ—¶é’ˆç”»åœˆ"; uiText.style.color="#fff"; }
            } else {
                lossCount++;
                if(lossCount > 15) {
                    lastAng = null;
                    st.tr = 0;
                    st.prog *= 0.95;
                    uiText.innerText="ä¿¡å·ä¸¢å¤±"; uiText.style.color="#555";
                }
            }
        }
        
        window.onresize = () => {
            cam3d.aspect = window.innerWidth/window.innerHeight;
            cam3d.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dr. Strange: Final Visual Fix</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: monospace; }
        
        /* 1. 视频层 */
        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; transform: scaleX(-1); object-fit: cover;
            opacity: 0.4; 
        }

        /* 2. 调试层 */
        #debug-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none; transform: scaleX(-1);
        }

        /* 3. 特效层 (确保在最上层) */
        #gl-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }

        /* UI */
        #hud { position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 20; }
        .status {
            background: rgba(0, 0, 0, 0.8); color: #ffaa00; padding: 12px 30px; 
            border: 2px solid #ffaa00; font-size: 18px; font-weight: bold; border-radius: 30px;
            box-shadow: 0 0 20px #ffaa00;
        }

        #start-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 100; padding: 20px 50px; font-size: 24px; font-weight: bold;
            background: #ffaa00; color: #000; border: 4px solid white; border-radius: 15px;
        }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 90; display: none;
            justify-content: center; align-items: center; color: #ffaa00;
        }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>
    <canvas id="debug-canvas"></canvas>
    
    <div id="loader">LOADING MAGIC...</div>
    <button id="start-btn" onclick="init()">START SYSTEM</button>
    <div id="hud"><div class="status" id="status">STANDBY</div></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const videoElement = document.getElementById('input-video');
        const debugCanvas = document.getElementById('debug-canvas');
        const debugCtx = debugCanvas.getContext('2d');
        const statusText = document.getElementById('status');
        
        // --- 1. VISUAL ENGINE ---
        const scene = new THREE.Scene();
        // Remove fog to ensure brightness
        // scene.fog = new THREE.FogExp2(0x000000, 0.05); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 14;

        const renderer = new THREE.WebGLRenderer({alpha: true, antialias: false});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = 'gl-canvas';
        document.body.appendChild(renderer.domElement);

        // -- Texture (Super Bright) --
        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
        const ctx = cvs.getContext('2d');
        const gr = ctx.createRadialGradient(32,32,0,32,32,32);
        gr.addColorStop(0,'#ffffff'); 
        gr.addColorStop(0.3,'#ffaa00'); 
        gr.addColorStop(0.6,'#ff4400'); 
        gr.addColorStop(1,'transparent');
        ctx.fillStyle=gr; ctx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(cvs);

        // -- Particle System --
        const COUNT = 5000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(COUNT*3);
        const col = new Float32Array(COUNT*3);
        const vel = new Float32Array(COUNT*3);
        const life = new Float32Array(COUNT);

        for(let i=0; i<COUNT; i++) { pos[i*3]=9999; life[i]=0; }
        
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        geo.setAttribute('color', new THREE.BufferAttribute(col,3));

        const mat = new THREE.PointsMaterial({
            size: 1.5, // INCREASED SIZE FOR IPAD
            map: tex, 
            transparent: true, 
            opacity: 1,
            vertexColors: true, 
            blending: THREE.AdditiveBlending, 
            depthWrite: false
        });
        const sys = new THREE.Points(geo, mat);
        // Move particles forward so they sit ON TOP of the black hole
        sys.position.z = 0.5; 
        scene.add(sys);

        // -- The Void (Black Hole) --
        const voidGeo = new THREE.CircleGeometry(1, 64);
        const voidMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const portalVoid = new THREE.Mesh(voidGeo, voidMat);
        portalVoid.position.z = 0; // Behind particles
        scene.add(portalVoid);

        // --- 2. LOGIC ---
        let State = { r:0, tr:0 };

        function animate() {
            requestAnimationFrame(animate);
            
            // Physics
            State.r += (State.tr - State.r) * 0.1;
            
            // Scale Void
            portalVoid.scale.setScalar(Math.max(0.01, State.r * 0.8));
            
            // Rotate System
            sys.rotation.z -= 0.03; 

            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                life[i] -= 0.025; // Die faster for more flicker

                if(life[i] <= 0) {
                    if(State.r > 0.5) {
                        // Respawn on Edge
                        const angle = Math.random() * 6.28;
                        const r = State.r + (Math.random()-0.5)*0.3;

                        pos[idx] = Math.cos(angle) * r;
                        pos[idx+1] = Math.sin(angle) * r;
                        pos[idx+2] = (Math.random()-0.5)*0.5;

                        // Tangential Velocity
                        const s = 0.2 + Math.random()*0.1;
                        vel[idx] = -Math.sin(angle)*s; 
                        vel[idx+1] = Math.cos(angle)*s; 
                        vel[idx+2] = 0;

                        life[i] = 1.0;
                    } else {
                        pos[idx] = 9999;
                    }
                } else {
                    pos[idx] += vel[idx];
                    pos[idx+1] += vel[idx+1];
                    pos[idx+2] += vel[idx+2];

                    // Color Update
                    const l = life[i];
                    if(l > 0.7) { col[idx]=1; col[idx+1]=1; col[idx+2]=1; } // White
                    else if(l > 0.4) { col[idx]=1; col[idx+1]=0.7; col[idx+2]=0; } // Gold
                    else { col[idx]=1; col[idx+1]=0.1; col[idx+2]=0; } // Red
                }
            }
            
            geo.attributes.position.needsUpdate = true;
            geo.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 3. HAND TRACKING ---
        async function init() {
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('loader').style.display = 'flex';

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 2, 
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            const cam = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 640, height: 480, facingMode: 'user'
            });
            await cam.start();
            
            document.getElementById('loader').style.display = 'none';
            resizeCanvas();
        }

        function onResults(results) {
            // Draw Skeleton
            debugCtx.save();
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(debugCtx, landmarks, HAND_CONNECTIONS, {color: '#00ff00', lineWidth: 2});
                    drawLandmarks(debugCtx, landmarks, {color: '#ff0000', lineWidth: 1, radius: 4});
                }
            }
            debugCtx.restore();

            // Distance Logic
            if (results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0][0];
                const h2 = results.multiHandLandmarks[1][0];
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                
                // Map distance to size
                // 0.15 (Close) -> 0.7 (Far)
                let openAmt = (dist - 0.15) * 2.5; 
                openAmt = Math.max(0, Math.min(1, openAmt));
                
                State.tr = openAmt * 6.5; // Max radius 6.5

                statusText.innerText = `POWER: ${(openAmt*100).toFixed(0)}%`;
                
            } else {
                State.tr = 0;
                statusText.innerText = "REQUIRE 2 HANDS";
            }
        }

        function resizeCanvas() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            debugCanvas.width = window.innerWidth;
            debugCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Strange Portal AR</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        /* This hides the raw video element, we only want the 3D canvas */
        .input_video {
            display: none;
        }
        /* The canvas sits on top */
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            font-size: 24px;
            pointer-events: none;
        }
    </style>
    
    <!-- Import Maps: This tells the browser where to get the libraries -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Loading Magic... (Allow Camera Access)</div>
    <video class="input_video"></video>

    <script type="module">
        import * as THREE from 'three';
        // We import MediaPipe libraries dynamically to ensure they load correctly in the browser
        const { Hands } = window; 
        const { Camera } = window;

        // ==========================================
        // 1. SETUP THREE.JS (The Graphics Engine)
        // ==========================================
        const scene = new THREE.Scene();
        
        // Perspective Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Renderer (Alpha: true allows us to see the webcam behind the 3D)
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==========================================
        // 2. CREATE THE PORTAL SHADERS (The Magic)
        // ==========================================
        
        // Vertex Shader: Controls movement (Spinning and sparking)
        const vertexShader = `
            uniform float uTime;
            uniform float uSize;
            attribute float aScale;
            attribute float aSpeed;
            attribute vec3 aRandomness;
            
            varying vec2 vUv;
            varying float vScale;

            void main() {
                vUv = uv;
                vScale = aScale;

                vec3 transformed = position;

                // 1. Calculate Rotation based on time and speed
                // The outer particles move faster than inner ones to create tearing effect
                float angle = uTime * aSpeed * 1.5;
                
                // 2. Apply Rotation Matrix (Z-axis spin)
                float c = cos(angle);
                float s = sin(angle);
                float x = transformed.x;
                float y = transformed.y;
                
                transformed.x = x * c - y * s;
                transformed.y = x * s + y * c;

                // 3. Add noise/shaking to simulate sparks
                transformed += aRandomness * sin(uTime * 10.0) * 0.05;

                vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
                
                // 4. Size attenuation (particles get smaller when far away)
                gl_PointSize = uSize * aScale * (100.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // Fragment Shader: Controls Color (Fire Gradient)
        const fragmentShader = `
            uniform vec3 uColorInner;
            uniform vec3 uColorOuter;
            
            varying float vScale;

            void main() {
                // Calculate distance from center of the particle (0.0 to 0.5)
                float d = distance(gl_PointCoord, vec2(0.5));
                
                // Create a soft glow circle
                if (d > 0.5) discard; // Cut off corners of the square point
                
                float glow = 0.05 / (d - 0.05); // Inverse square law for glow
                glow = pow(glow, 2.0); // Sharpen it

                // Mix colors based on distance from center
                vec3 finalColor = mix(uColorOuter, uColorInner, d * 2.0);

                // Add transparency at edges
                float alpha = 1.0 - smoothstep(0.4, 0.5, d);

                gl_FragColor = vec4(finalColor, alpha * vScale);
            }
        `;

        // ==========================================
        // 3. BUILD THE PORTAL GEOMETRY
        // ==========================================
        const particlesGeometry = new THREE.BufferGeometry();
        const count = 4000; // 4000 sparks
        
        const positions = new Float32Array(count * 3);
        const scales = new Float32Array(count);
        const speeds = new Float32Array(count);
        const randomness = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            
            // Create a Ring Shape
            // We use polar coordinates (radius & angle) then convert to X,Y
            const radius = 1.8 + (Math.random() - 0.5) * 0.6; // Base radius 1.8 with variation
            const angle = Math.random() * Math.PI * 2;

            positions[i3] = Math.cos(angle) * radius;     // X
            positions[i3 + 1] = Math.sin(angle) * radius; // Y
            positions[i3 + 2] = (Math.random() - 0.5) * 0.5; // Z (Depth thickness)

            scales[i] = Math.random();
            speeds[i] = 1.0 + Math.random(); // Varied rotation speeds
            
            // Random jitter vector
            randomness[i3] = Math.random() - 0.5;
            randomness[i3 + 1] = Math.random() - 0.5;
            randomness[i3 + 2] = Math.random() - 0.5;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
        particlesGeometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));
        particlesGeometry.setAttribute('aRandomness', new THREE.BufferAttribute(randomness, 3));

        // Create the Material
        const particlesMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uSize: { value: 150.0 },
                uColorInner: { value: new THREE.Color('#ffddaa') }, // Bright Yellow
                uColorOuter: { value: new THREE.Color('#ff4400') }  // Deep Orange/Red
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending // THIS MAKES IT GLOW
        });

        const portal = new THREE.Points(particlesGeometry, particlesMaterial);
        
        // Initially hide the portal until hand is found
        portal.visible = false; 
        scene.add(portal);


        // ==========================================
        // 4. SETUP WEBCAM BACKGROUND
        // ==========================================
        // We create a simple plane behind the portal to show the video
        const videoElement = document.getElementsByClassName('input_video')[0];
        const videoTexture = new THREE.VideoTexture(videoElement);
        const videoGeo = new THREE.PlaneGeometry(16, 9);
        const videoMat = new THREE.MeshBasicMaterial({ map: videoTexture });
        const videoMesh = new THREE.Mesh(videoGeo, videoMat);
        
        // Push it back so the portal is in front
        videoMesh.position.z = -5; 
        
        // Scale it to cover the screen
        const scaleFactor = Math.max(window.innerWidth / 16, window.innerHeight / 9) * 0.6; 
        videoMesh.scale.set(scaleFactor, scaleFactor, 1);
        
        scene.add(videoMesh);


        // ==========================================
        // 5. MEDIAPIPE (HAND TRACKING)
        // ==========================================
        
        // We need to load the scripts from CDN manually since we aren't using a bundler
        // Helper function to load scripts sequentially
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        }

        async function initMediaPipe() {
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js');
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');

            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            const camera = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
            
            camera.start();
            document.getElementById('loading').style.display = 'none';
        }

        // Variable to smooth out the movement
        const targetPosition = new THREE.Vector3();

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Landmark 8 is the tip of the Index Finger
                const indexFinger = landmarks[8];
                
                // Convert 2D screen coordinates to 3D world coordinates
                // MediaPipe x/y are 0.0 to 1.0
                
                // We map this to our camera view range (roughly -4 to 4 on X, -2 to 2 on Y at z=0)
                const x = (indexFinger.x - 0.5) * -10.0; // Invert X for mirror effect
                const y = -(indexFinger.y - 0.5) * 8.0;  // Invert Y because 3D Y goes up

                targetPosition.set(x, y, 0);
                
                portal.visible = true;
            } else {
                // Optional: Hide portal if no hand detected
                // portal.visible = false; 
            }
        }


        // ==========================================
        // 6. ANIMATION LOOP
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();

            // Update Shader Time
            particlesMaterial.uniforms.uTime.value = elapsedTime;

            // Smoothly move portal to hand position (Linear Interpolation)
            portal.position.lerp(targetPosition, 0.1);

            // Update Video Aspect Ratio (Responsive background)
            if(videoElement.readyState === videoElement.HAVE_ENOUGH_DATA){
                 const videoAspect = videoElement.videoWidth / videoElement.videoHeight;
                 const screenAspect = window.innerWidth / window.innerHeight;
                 
                 // Simple logic to cover the screen
                 if(screenAspect > videoAspect) {
                     videoMesh.scale.set(screenAspect * 5, screenAspect * 5, 1);
                 } else {
                     videoMesh.scale.set(5, 5, 1);
                 }
            }

            renderer.render(scene, camera);
        }

        // Start everything
        initMediaPipe().then(() => {
            animate();
        }).catch(err => {
            console.error("Error loading MediaPipe", err);
            document.getElementById('loading').innerText = "Error loading. Check console.";
        });

    </script>
</body>
</html>

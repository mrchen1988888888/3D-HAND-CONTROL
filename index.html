<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 Cinematic Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s;
        }

        .btn-start {
            padding: 15px 50px; background: transparent; 
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #FFD700; font-size: 1.2rem; letter-spacing: 4px;
            cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            transition: all 0.4s;
        }
        .btn-start:hover {
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.6);
            border-color: #fff; color: #fff;
        }

        #loading-text { color: #444; margin-bottom: 20px; font-size: 0.8rem; letter-spacing: 2px; }
        #webgl-container { width: 100%; height: 100vh; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="overlay">
        <div id="loading-text">INITIALIZING SHADERS...</div>
        <button class="btn-start" id="btn-start" style="display:none;">IGNITE 2025</button>
    </div>

    <div id="webgl-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            textColor: new THREE.Color(0xffaa00), // Gold
            ringColors: [
                new THREE.Color(0x00ffff), // Cyan
                new THREE.Color(0x9d00ff), // Purple
                new THREE.Color(0xffd700)  // Gold
            ],
            particleCountText: 15000, // High density text
            particleCountRing: 5000   // High density ring
        };

        let scene, camera, renderer, composer;
        let textPoints, ringPoints;
        let uniformsText, uniformsRing;

        // --- SHADERS (The Magic) ---
        
        // 1. Vertex Shader: Handles position and movement
        const vertexShader = `
            uniform float uTime;
            uniform float uSize;
            attribute float aRandom;
            attribute vec3 aColor;
            
            varying vec3 vColor;
            varying float vAlpha;

            // Simplex Noise Function
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) { 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; 
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                              dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                vColor = aColor;
                vec3 pos = position;

                // 1. Drift Effect (Noise)
                float noiseFreq = 0.5;
                float noiseAmp = 0.8; 
                vec3 noisePos = vec3(pos.x * noiseFreq + uTime, pos.y * noiseFreq + uTime, uTime);
                pos.x += snoise(noisePos) * noiseAmp;
                pos.y += snoise(noisePos + 100.0) * noiseAmp;
                pos.z += snoise(noisePos + 200.0) * noiseAmp;

                // 2. Twinkle Size (Sine wave based on time + random)
                float twinkle = sin(uTime * 3.0 + aRandom * 10.0);
                vAlpha = 0.5 + 0.5 * twinkle; // Alpha oscillates between 0.0 and 1.0

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // 3. Size Attenuation (Particles smaller when further away)
                gl_PointSize = uSize * (1.0 + twinkle * 0.3); // Pulse size
                gl_PointSize *= (300.0 / -mvPosition.z);
            }
        `;

        // 2. Fragment Shader: Handles shape and glow
        const fragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                // Soft Circle Calculation
                float r = distance(gl_PointCoord, vec2(0.5));
                if (r > 0.5) discard; // Cut circle

                // Radial Glow
                float glow = 1.0 - (r * 2.0);
                glow = pow(glow, 1.5); // Soft falloff

                gl_FragColor = vec4(vColor, vAlpha * glow);
            }
        `;


        // --- Init ---
        function init() {
            const container = document.getElementById('webgl-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            // Deep fog to hide limits
            scene.fog = new THREE.FogExp2(0x000000, 0.002); 

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 120);

            // Renderer with Tone Mapping for Cinematic look
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Optimized
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            // --- Post Processing (Bloom) ---
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.0; // Glow everything
            bloomPass.strength = 1.5;  // Strong cinematic glow
            bloomPass.radius = 0.8;    // Wide spread

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- Create Objects ---
            createTextSystem();
            createFireworkRing();

            window.addEventListener('resize', onResize);
            
            document.getElementById('loading-text').style.display = 'none';
            document.getElementById('btn-start').style.display = 'block';
        }

        // --- 1. Text Generation (Canvas -> Shader) ---
        function createTextSystem() {
            // 1. Draw text to canvas
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,1024,512);
            
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            
            ctx.font = 'bold 150px "Times New Roman"';
            ctx.fillText('2026', 512, 200);
            
            ctx.font = 'bold 40px "Segoe UI"';
            ctx.letterSpacing = '10px';
            ctx.fillText('HAPPY NEW YEAR', 512, 320);

            // 2. Scan pixels
            const imgData = ctx.getImageData(0,0,1024,512).data;
            const positions = [];
            const randoms = [];
            const colors = [];

            for(let y=0; y<512; y+=3) { // Step 3 for density
                for(let x=0; x<1024; x+=3) {
                    if(imgData[(y*1024+x)*4] > 128) {
                        // Position
                        const px = (x - 512) * 0.35;
                        const py = -(y - 256) * 0.35;
                        const pz = (Math.random() - 0.5) * 5; // Thickness
                        positions.push(px, py, pz);
                        
                        // Attribute: Random (for animation offset)
                        randoms.push(Math.random());

                        // Attribute: Color (Gold Gradient)
                        // Add some white sparkles
                        if(Math.random() > 0.9) {
                            colors.push(1.0, 1.0, 1.0);
                        } else {
                            // Slight variation in gold
                            colors.push(1.0, 0.8 + Math.random()*0.2, 0.2);
                        }
                    }
                }
            }

            // 3. Create Geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));

            // 4. Create Shader Material
            uniformsText = {
                uTime: { value: 0 },
                uSize: { value: 6.0 } // Particle Size
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniformsText,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            textPoints = new THREE.Points(geometry, material);
            scene.add(textPoints);
        }

        // --- 2. Firework Ring Generation ---
        function createFireworkRing() {
            const positions = [];
            const randoms = [];
            const colors = [];
            const count = 8000;

            for(let i=0; i<count; i++) {
                // Ring Shape
                const angle = Math.random() * Math.PI * 2;
                const radius = 60 + Math.random() * 20; // Wide ring
                
                // Position
                const px = Math.cos(angle) * radius;
                const py = (Math.random() - 0.5) * 10 - 40; // Below text
                const pz = Math.sin(angle) * radius; // 3D depth
                
                positions.push(px, py, pz);
                randoms.push(Math.random());

                // Color Palette
                const col = CONFIG.ringColors[Math.floor(Math.random() * CONFIG.ringColors.length)];
                colors.push(col.r, col.g, col.b);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));

            uniformsRing = {
                uTime: { value: 0 },
                uSize: { value: 4.0 }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniformsRing,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            ringPoints = new THREE.Points(geometry, material);
            scene.add(ringPoints);
        }

        // --- Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // Update Uniforms
            if(uniformsText) uniformsText.uTime.value = time;
            if(uniformsRing) uniformsRing.uTime.value = time;

            // Camera Movement (Cinematic drift)
            if(camera) {
                camera.position.x = Math.sin(time * 0.2) * 20;
                camera.position.y = Math.cos(time * 0.3) * 10;
                camera.lookAt(0, 0, 0);
            }

            // Ring Rotation
            if(ringPoints) {
                ringPoints.rotation.y = -time * 0.1;
                // Add wave motion
                ringPoints.rotation.z = Math.sin(time * 0.5) * 0.05;
            }

            composer.render();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        document.getElementById('btn-start').addEventListener('click', () => {
            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('overlay').style.display='none', 1000);
            init();
        });

    </script>
</body>
</html>

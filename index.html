<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dr. Strange Portal (PC Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: Consolas, monospace; }
        
        /* 容器用于叠放画布 */
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }

        /* 1. 摄像头和骨架层 (2D) */
        #output-canvas {
            position: absolute;
            z-index: 1;
            /* 保持比例，最大化显示 */
            max-width: 100%; max-height: 100%;
            transform: scaleX(-1); /* 镜像 */
        }

        /* 2. 魔法特效层 (3D) */
        #three-canvas {
            position: absolute;
            z-index: 2;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* 3. 日志面板 */
        #debug-panel {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(0,0,0,0.8); color: #0f0; padding: 15px;
            border: 1px solid #004400; width: 300px; max-height: 200px;
            overflow-y: auto; font-size: 12px; pointer-events: none;
        }
        .log-err { color: #f00; border-top: 1px solid #500; margin-top: 5px; padding-top: 5px; }
        .log-ok { color: #0f0; }
        .log-warn { color: #fa0; }

        /* 4. 状态提示大字 */
        #hud {
            position: absolute; bottom: 50px; width: 100%; text-align: center; z-index: 50;
            pointer-events: none;
        }
        .status {
            display: inline-block; background: rgba(0,0,0,0.7); color: #f5a623;
            padding: 10px 30px; border-radius: 50px; font-size: 24px; font-weight: bold;
            border: 2px solid #f5a623; text-transform: uppercase;
            box-shadow: 0 0 20px rgba(245, 166, 35, 0.4);
        }
    </style>
</head>
<body>

    <div id="debug-panel">
        <div>[SYSTEM] Initializing PC Environment...</div>
    </div>

    <div id="container">
        <!-- 原始视频流(隐藏) -->
        <video id="input-video" style="display:none"></video>
        <!-- 视觉输出 -->
        <canvas id="output-canvas"></canvas>
        <canvas id="three-canvas"></canvas>
    </div>

    <div id="hud">
        <div class="status" id="status-text">LOADING AI...</div>
    </div>

    <!-- 依赖库 (国际源) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const logBox = document.getElementById('debug-panel');
        function log(msg, type='info') {
            const d = document.createElement('div');
            d.innerText = `> ${msg}`;
            if(type==='error') d.className='log-err';
            if(type==='warn') d.className='log-warn';
            logBox.appendChild(d);
            logBox.scrollTop = logBox.scrollHeight;
        }

        const statusText = document.getElementById('status-text');

        // --- 1. Three.js (粒子特效) ---
        log("Step 1: Starting Graphics Engine...");
        
        const threeCanvas = document.getElementById('three-canvas');
        const scene = new THREE.Scene();
        // 注意：不设置背景色，保持透明
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

        // 纹理：程序化生成发光火花
        const cvs = document.createElement('canvas');
        cvs.width = 128; cvs.height = 128;
        const ctx = cvs.getContext('2d');
        const grd = ctx.createRadialGradient(64,64,0, 64,64,64);
        grd.addColorStop(0, '#ffffff');
        grd.addColorStop(0.2, '#ffcc00'); // 金色
        grd.addColorStop(0.5, '#ff6600'); // 橙色
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(0,0,128,128);
        const texture = new THREE.CanvasTexture(cvs);

        // 粒子系统
        const COUNT = 4000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(COUNT * 3);
        // data: x=speed, y=angle, z=radius_offset
        const data = new Float32Array(COUNT * 3); 
        
        for(let i=0; i<COUNT; i++) {
            pos[i*3] = 9999; // 初始移出屏幕
            data[i*3] = 1 + Math.random() * 5;       // 速度
            data[i*3+1] = Math.random() * Math.PI * 2; // 角度
            data[i*3+2] = (Math.random() - 0.5) * 2.0; // 环的厚度
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        
        const mat = new THREE.PointsMaterial({
            size: 0.6, // 粒子调大一点，PC屏幕大
            map: texture,
            transparent: true,
            blending: THREE.AdditiveBlending, // 关键：发光混合模式
            depthWrite: false,
            color: 0xffaa00
        });

        const portal = new THREE.Points(geo, mat);
        scene.add(portal);

        let State = { radius: 0, targetRadius: 0 };

        function animate() {
            requestAnimationFrame(animate);
            
            // 缓动
            State.radius += (State.targetRadius - State.radius) * 0.1;
            
            // 旋转
            portal.rotation.z -= 0.03;

            const p = portal.geometry.attributes.position.array;
            
            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                data[idx+1] += data[idx] * 0.01; // 更新角度
                
                const angle = data[idx+1];
                const r = State.radius + data[idx+2]; // 基础半径 + 偏移

                if (State.radius > 0.5) {
                    // 显示粒子
                    p[idx] = Math.cos(angle) * r;
                    p[idx+1] = Math.sin(angle) * r;
                    p[idx+2] = (Math.random()-0.5) * 2; // Z轴厚度
                } else {
                    p[idx] = 9999;
                }
            }
            portal.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 2. MediaPipe (AI 识别) ---
        log("Step 2: Loading AI Models (VPN Required)...");

        const video = document.getElementById('input-video');
        const canvas2d = document.getElementById('output-canvas');
        const ctx2d = canvas2d.getContext('2d');

        const hands = new Hands({locateFile: (file) => {
            log(`Downloading: ${file}...`);
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2, // 检测双手
            modelComplexity: 1, // PC端使用高精度模型
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        let isModelLoaded = false;

        hands.onResults(results => {
            if(!isModelLoaded) {
                isModelLoaded = true;
                log("AI Ready! Waiting for hands...", 'log-ok');
                statusText.innerText = "Please Raise Both Hands";
            }

            // 1. 绘制背景 (摄像头画面)
            canvas2d.width = video.videoWidth;
            canvas2d.height = video.videoHeight;
            ctx2d.save();
            ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
            ctx2d.drawImage(results.image, 0, 0, canvas2d.width, canvas2d.height);

            // 2. 处理手势
            if (results.multiHandLandmarks.length === 2) {
                // 检测到双手
                const h1 = results.multiHandLandmarks[0][9]; // 手掌中心点
                const h2 = results.multiHandLandmarks[1][9];

                // 绘制骨架
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(ctx2d, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
                    drawLandmarks(ctx2d, landmarks, {color: '#FF0000', lineWidth: 1, radius: 4});
                }

                // 计算距离 (MediaPipe 坐标 0.0-1.0)
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                
                // 映射逻辑：距离 0.1 -> 半径 0，距离 0.6 -> 半径 8
                let target = (dist - 0.1) * 16;
                target = Math.max(0, Math.min(target, 10)); // 限制最大半径
                
                State.targetRadius = target;
                
                if (target > 1) {
                    statusText.innerText = "PORTAL OPEN";
                    statusText.style.borderColor = "#00ff88";
                    statusText.style.color = "#00ff88";
                } else {
                    statusText.innerText = "PULL HANDS APART";
                    statusText.style.color = "#f5a623";
                }

            } else {
                // 没有检测到双手
                State.targetRadius = 0;
                if (results.multiHandLandmarks.length === 1) {
                    // 只检测到一只手，画出来
                    drawConnectors(ctx2d, results.multiHandLandmarks[0], HAND_CONNECTIONS, {color: '#ffff00', lineWidth: 3});
                    statusText.innerText = "NEED TWO HANDS";
                    statusText.style.borderColor = "#ffff00";
                    statusText.style.color = "#ffff00";
                } else {
                    statusText.innerText = "NO HANDS DETECTED";
                    statusText.style.borderColor = "#555";
                    statusText.style.color = "#555";
                }
            }
            ctx2d.restore();
        });

        // --- 3. 摄像头启动 ---
        log("Step 3: Accessing Webcam...");
        
        const cameraUtils = new Camera(video, {
            onFrame: async () => {
                await hands.send({image: video});
            },
            width: 1280, // PC端尝试使用高清分辨率
            height: 720
        });

        cameraUtils.start()
            .then(() => log("Webcam Active. Stream running.", 'log-ok'))
            .catch(e => {
                log(`Webcam Failed: ${e.message}`, 'error');
                statusText.innerText = "CAMERA ERROR";
                statusText.style.color = "red";
            });

        // 窗口大小适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

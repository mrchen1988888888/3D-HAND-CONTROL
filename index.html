<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>é­”æ³•ä¼ é€é—¨(è°ƒè¯•ç‰ˆ)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            opacity: 0; pointer-events: none; z-index: -1; 
            transform: scaleX(-1);
        }
        
        /* è°ƒè¯•æ—¥å¿—çª—å£ (å±å¹•ä¸Šæ–¹) */
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%; height: 50%;
            background: rgba(0,0,0,0.8); z-index: 999;
            padding: 15px; box-sizing: border-box;
            color: #00ff88; font-family: monospace; font-size: 12px;
            overflow-y: auto; pointer-events: none;
            border-bottom: 2px solid #f5a623;
        }

        #hud {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; z-index: 10; width: 100%;
        }
        .title {
            color: #f5a623; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px rgba(245, 166, 35, 0.8);
            letter-spacing: 2px; margin-bottom: 10px;
        }
        .subtitle {
            color: rgba(255,255,255,0.8); font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 20px;
            border: 1px solid rgba(245, 166, 35, 0.3);
            display: inline-block;
        }
        
        #energy-bar-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 200px; height: 200px; pointer-events: none; opacity: 0.6; z-index: 5;
        }
        
        .loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200;
        }
        .spinner { width: 50px; height: 50px; border: 3px solid #333; border-top: 3px solid #f5a623; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .log-error { color: #ff5555; font-weight: bold; border: 1px solid red; padding: 5px; margin: 5px 0; }
        .log-success { color: #00ff88; }
        .log-warn { color: #ffff00; }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <!-- è°ƒè¯•æ—¥å¿—åŒºåŸŸ -->
    <div id="debug-console">
        <div style="color:white; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:5px;">ç³»ç»Ÿè‡ªæ£€æ§åˆ¶å°</div>
        <div id="log-content"></div>
    </div>

    <div id="loading" class="loading-mask">
        <div class="spinner"></div>
        <div style="color:#f5a623; font-size: 16px;">ç³»ç»Ÿå¯åŠ¨ä¸­...</div>
        <div style="color:#aaa; font-size:12px; margin-top:10px;">è¯·æŸ¥çœ‹ä¸Šæ–¹æ—¥å¿—</div>
    </div>
    
    <div id="hud">
        <div class="title">DOCTOR STRANGE</div>
        <div class="subtitle" id="status-text">åˆå§‹åŒ–...</div>
    </div>

    <div id="energy-bar-container">
        <svg width="200" height="200" viewBox="0 0 200 200">
            <circle cx="100" cy="100" r="40" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2" />
            <circle id="progress-ring" cx="100" cy="100" r="40" fill="none" stroke="#f5a623" stroke-width="4" stroke-dasharray="251" stroke-dashoffset="251" transform="rotate(-90 100 100)" stroke-linecap="round" />
        </svg>
    </div>

    <!-- æ¢å› unpkg æºï¼Œè™½ç„¶æ…¢ä¸€ç‚¹ç‚¹ï¼Œä½†æ–‡ä»¶ç»“æ„æ›´ç¨³å®š -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- æ—¥å¿—ç³»ç»Ÿ ---
        const logBox = document.getElementById('log-content');
        function log(msg, type='info') {
            const div = document.createElement('div');
            const time = new Date().toLocaleTimeString();
            div.innerText = `[${time}] ${msg}`;
            if(type === 'error') div.className = 'log-error';
            else if(type === 'success') div.className = 'log-success';
            else if(type === 'warn') div.className = 'log-warn';
            logBox.appendChild(div);
            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            document.getElementById('debug-console').scrollTop = document.getElementById('debug-console').scrollHeight;
        }

        window.onerror = function(msg, url, line) {
            log(`âŒ ä»£ç é”™è¯¯: ${msg} (Line:${line})`, 'error');
            return false;
        };

        log("ğŸš€ å¼€å§‹åˆå§‹åŒ–ç¨‹åº...");

        // --- 1. Three.js ---
        let scene, camera, renderer, portalRing, mirrorWorld;
        try {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.body.appendChild(renderer.domElement);
            log("âœ… Three.js å›¾å½¢å¼•æ“å¯åŠ¨æˆåŠŸ", 'success');
        } catch(e) {
            log("âŒ WebGL å¯åŠ¨å¤±è´¥: " + e.message, 'error');
        }

        function createSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.2, 'rgba(255, 200, 50, 1)');
            grad.addColorStop(0.4, 'rgba(255, 100, 0, 0.8)');
            grad.addColorStop(1, 'rgba(100, 0, 0, 0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const sparkTexture = createSparkTexture();
        const PARTICLE_COUNT = 3000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        const speeds = new Float32Array(PARTICLE_COUNT);
        const angles = new Float32Array(PARTICLE_COUNT);
        const radii = new Float32Array(PARTICLE_COUNT);
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            angles[i] = Math.random() * Math.PI * 2;
            radii[i] = (Math.random() - 0.5) * 1.5;
            speeds[i] = 2 + Math.random() * 3;
            positions[i*3] = 9999; positions[i*3+1] = 9999; positions[i*3+2] = 0;
            sizes[i] = Math.random() * 0.5 + 0.1;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.3, color: 0xffaa00, map: sparkTexture,
            transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        portalRing = new THREE.Points(geometry, material);
        scene.add(portalRing);

        const mirrorGeo = new THREE.IcosahedronGeometry(1, 2);
        const mirrorMat = new THREE.MeshBasicMaterial({ color: 0x001133, wireframe: true, transparent: true, opacity: 0 });
        mirrorWorld = new THREE.Mesh(mirrorGeo, mirrorMat);
        scene.add(mirrorWorld);

        let portalState = { currentRadius: 0, targetRadius: 0, maxRadius: 6, rotationProgress: 0 };

        function animate() {
            requestAnimationFrame(animate);
            portalState.currentRadius += (portalState.targetRadius - portalState.currentRadius) * 0.05;
            mirrorWorld.scale.setScalar(portalState.currentRadius * 0.9);
            mirrorWorld.material.opacity = Math.min(1, portalState.currentRadius / 3);
            mirrorWorld.rotation.y += 0.01; mirrorWorld.rotation.z += 0.005;
            
            const posAttr = portalRing.geometry.attributes.position;
            const posArr = posAttr.array;
            portalRing.rotation.z -= 0.02; 

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const idx = i*3;
                angles[i] += speeds[i] * 0.01;
                const r = portalState.currentRadius + radii[i];
                if (portalState.currentRadius > 0.1) {
                    posArr[idx] = Math.cos(angles[i]) * r + (Math.random()-0.5)*0.1;
                    posArr[idx+1] = Math.sin(angles[i]) * r + (Math.random()-0.5)*0.1;
                    posArr[idx+2] = (Math.random() - 0.5) * 0.5;
                } else {
                    posArr[idx] = 9999;
                }
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 2. MediaPipe åˆå§‹åŒ– ---
        log("â³ æ­£åœ¨åŠ è½½ AI æ ¸å¿ƒ...");
        
        const circleRing = document.getElementById('progress-ring');
        const statusText = document.getElementById('status-text');
        let lastAngle = null;

        function getAngle(x, y) { return Math.atan2(y - 0.5, x - 0.5); }

        // ä½¿ç”¨ unpkg æ›¿ä»£ elemecdnï¼Œè™½ç„¶æ…¢ä¸€ç‚¹ä½†æ›´ç¨³å®š
        const hands = new Hands({locateFile: (file) => {
            log(`ğŸ“¥ è¯·æ±‚æ¨¡å‹æ–‡ä»¶: ${file}`);
            return `https://unpkg.com/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        let isModelLoaded = false;
        
        hands.onResults((results) => {
            if (!isModelLoaded) {
                isModelLoaded = true;
                log("ğŸ‰ AI æ¨¡å‹åŠ è½½æˆåŠŸï¼", 'success');
                document.getElementById('loading').style.display = 'none';
                document.getElementById('debug-console').style.display = 'none'; // æˆåŠŸåéšè—è°ƒè¯•æ¡†
            }

            const handsDetected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            if (handsDetected) {
                const lm = results.multiHandLandmarks[0];
                const fingerTip = lm[8]; 
                const currentAngle = getAngle(fingerTip.x, fingerTip.y);
                
                if (lastAngle !== null) {
                    let delta = currentAngle - lastAngle;
                    if (delta > Math.PI) delta -= Math.PI * 2;
                    if (delta < -Math.PI) delta += Math.PI * 2;
                    if (Math.abs(delta) < 0.5) {
                        portalState.rotationProgress += delta * 1.5; 
                    }
                }
                lastAngle = currentAngle;
                const MAX_ROTATION = Math.PI * 4;
                portalState.rotationProgress = Math.max(0, Math.min(portalState.rotationProgress, MAX_ROTATION));
                const progressRatio = portalState.rotationProgress / MAX_ROTATION;
                portalState.targetRadius = progressRatio * portalState.maxRadius;
                circleRing.style.strokeDashoffset = 251 - (251 * progressRatio);
                
                if (progressRatio < 0.1) {
                    statusText.innerText = "ä¸¾èµ·é£ŸæŒ‡ é¡ºæ—¶é’ˆç”»åœˆ"; statusText.style.color = "#aaa";
                } else if (progressRatio < 0.9) {
                    statusText.innerText = `å……èƒ½ä¸­... ${(progressRatio*100).toFixed(0)}%`; statusText.style.color = "#f5a623";
                } else {
                    statusText.innerText = "ä¼ é€é—¨å¼€å¯"; statusText.style.color = "#00ff88";
                }
            } else {
                lastAngle = null;
                statusText.innerText = "ä¿¡å·ä¸¢å¤± - ä¼ é€é—¨é—­åˆ";
                portalState.targetRadius = 0;
                portalState.rotationProgress *= 0.95; 
            }
        });

        // å¯åŠ¨æ‘„åƒå¤´
        log("ğŸ“· æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...");
        const cameraUtils = new Camera(document.getElementById('input-video'), {
            onFrame: async () => {
                await hands.send({image: document.getElementById('input-video')});
            },
            width: 640, height: 480, facingMode: 'user'
        });
        
        cameraUtils.start()
            .then(() => {
                log("âœ… æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ", 'success');
                log("â³ ç­‰å¾… AI æ¨¡å‹ä¸‹è½½... (è‹¥æ­¤å¤„å¡ä½è¯·æ£€æŸ¥ç½‘ç»œ)", 'warn');
            })
            .catch(e => {
                log(`âŒ æ‘„åƒå¤´é”™è¯¯: ${e.message}`, 'error');
                log("ğŸ’¡ è¯·æ£€æŸ¥ï¼š1.æ˜¯å¦å…è®¸äº†æƒé™ 2.æ˜¯å¦æ˜¯HTTPSé“¾æ¥", 'warn');
            });
            
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    </script>
</body>
</html>

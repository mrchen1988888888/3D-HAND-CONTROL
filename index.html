<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>奇异博士：魔法传送门</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            opacity: 0; pointer-events: none; z-index: -1; 
            transform: scaleX(-1); /* 镜像翻转 */
        }
        
        /* 电影字幕风格 UI */
        #hud {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; z-index: 10;
            width: 80%;
        }
        .title {
            color: #f5a623; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px rgba(245, 166, 35, 0.8);
            letter-spacing: 2px; margin-bottom: 10px;
            font-family: 'Cinzel', serif; /* 类似电影字体 */
        }
        .subtitle {
            color: rgba(255,255,255,0.8); font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 20px;
            border: 1px solid rgba(245, 166, 35, 0.3);
            display: inline-block;
        }

        /* 进度条 (充能条) */
        #energy-bar-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 200px; height: 200px; pointer-events: none; opacity: 0.6;
            z-index: 5;
        }
        /* 动态生成的 SVG 圆环 */
        
        .loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200;
        }
        .spinner { width: 50px; height: 50px; border: 3px solid #333; border-top: 3px solid #f5a623; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        #debug-log { color: #555; font-size: 12px; margin-top: 10px; }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loading" class="loading-mask">
        <div class="spinner"></div>
        <div style="color:#f5a623; font-size: 16px; font-weight:bold;">正在汲取维山帝之力...</div>
        <div id="debug-log">连接魔法网络中...</div>
    </div>
    
    <div id="hud">
        <div class="title">SLING RING PORTAL</div>
        <div class="subtitle" id="status-text">举起食指，顺时针画圈开启传送门</div>
    </div>

    <!-- 能量指示器 -->
    <div id="energy-bar-container">
        <svg width="200" height="200" viewBox="0 0 200 200">
            <circle cx="100" cy="100" r="40" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2" />
            <circle id="progress-ring" cx="100" cy="100" r="40" fill="none" stroke="#f5a623" stroke-width="4" stroke-dasharray="251" stroke-dashoffset="251" transform="rotate(-90 100 100)" stroke-linecap="round" />
        </svg>
    </div>

    <!-- 国内加速源 -->
    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js"></script>

    <script>
        // 日志
        function log(msg) { document.getElementById('debug-log').innerText = msg; console.log(msg); }

        // --- 1. Three.js 初始化 ---
        const scene = new THREE.Scene();
        // 稍微加点环境雾
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); // 背景不透明，要是黑色的
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // --- 2. 核心：生成火花纹理 (Canvas) ---
        // 动态生成一个发光的黄色光点贴图，避免加载外部图片
        function createSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');     // 中心白
            grad.addColorStop(0.2, 'rgba(255, 200, 50, 1)');    // 内圈金
            grad.addColorStop(0.4, 'rgba(255, 100, 0, 0.8)');   // 中圈橙
            grad.addColorStop(1, 'rgba(100, 0, 0, 0)');         // 边缘透明
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        const sparkTexture = createSparkTexture();

        // --- 3. 传送门粒子系统 ---
        const PARTICLE_COUNT = 3000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        const speeds = new Float32Array(PARTICLE_COUNT); // 旋转速度
        const angles = new Float32Array(PARTICLE_COUNT); // 当前角度
        const radii = new Float32Array(PARTICLE_COUNT);  // 轨道半径偏移
        
        // 初始化粒子
        for(let i=0; i<PARTICLE_COUNT; i++) {
            angles[i] = Math.random() * Math.PI * 2;
            radii[i] = (Math.random() - 0.5) * 1.5; // 环的厚度
            speeds[i] = 2 + Math.random() * 3; // 基础速度
            
            // 初始全部藏起来
            positions[i*3] = 9999;
            positions[i*3+1] = 9999;
            positions[i*3+2] = 0;
            
            sizes[i] = Math.random() * 0.5 + 0.1;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // 材质：使用加法混合(AdditiveBlending)让光叠加变亮
        const material = new THREE.PointsMaterial({
            size: 0.3,
            color: 0xffaa00,
            map: sparkTexture,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: false
        });

        const portalRing = new THREE.Points(geometry, material);
        scene.add(portalRing);

        // --- 4. 传送门内部 (另一维度) ---
        // 一个简单的网格球体代表“镜像空间”
        const mirrorGeo = new THREE.IcosahedronGeometry(1, 2);
        const mirrorMat = new THREE.MeshBasicMaterial({ 
            color: 0x001133, 
            wireframe: true,
            transparent: true,
            opacity: 0
        });
        const mirrorWorld = new THREE.Mesh(mirrorGeo, mirrorMat);
        scene.add(mirrorWorld);


        // --- 状态变量 ---
        let portalState = {
            currentRadius: 0,   // 当前半径 (0 = 关闭)
            targetRadius: 0,    // 目标半径
            maxRadius: 6,       // 最大半径
            rotationProgress: 0,// 手势累积的角度
            isOpen: false
        };

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 1. 缓动逻辑：平滑半径变化
            portalState.currentRadius += (portalState.targetRadius - portalState.currentRadius) * 0.05;
            
            // 如果半径太小，就不渲染内部世界
            mirrorWorld.scale.setScalar(portalState.currentRadius * 0.9);
            mirrorWorld.material.opacity = Math.min(1, portalState.currentRadius / 3);
            mirrorWorld.rotation.y += 0.01;
            mirrorWorld.rotation.z += 0.005;

            // 2. 粒子物理更新
            const posAttr = portalRing.geometry.attributes.position;
            const posArr = posAttr.array;
            
            // 整体圆环旋转
            portalRing.rotation.z -= 0.02; 

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const idx = i*3;
                
                // 让粒子沿圆周运动
                angles[i] += speeds[i] * 0.01;
                
                // 核心形状逻辑
                // 半径 = 基础半径 + 随机偏移 + 噪音
                const r = portalState.currentRadius + radii[i];
                
                // 只有当半径 > 0.1 时才显示粒子，否则藏起来
                if (portalState.currentRadius > 0.1) {
                    // 模拟火花飞溅：加上一点随机抖动
                    const jitterX = (Math.random() - 0.5) * 0.1;
                    const jitterY = (Math.random() - 0.5) * 0.1;
                    
                    posArr[idx] = Math.cos(angles[i]) * r + jitterX;
                    posArr[idx+1] = Math.sin(angles[i]) * r + jitterY;
                    posArr[idx+2] = (Math.random() - 0.5) * 0.5; // Z轴轻微厚度
                } else {
                    posArr[idx] = 9999; // 隐藏
                }
            }
            
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();


        // --- 5. 手势交互逻辑 ---
        
        let lastAngle = null;
        const circleRing = document.getElementById('progress-ring');
        const statusText = document.getElementById('status-text');
        
        // 计算点(x,y)相对于屏幕中心(0.5, 0.5)的角度
        function getAngle(x, y) {
            // MediaPipe 坐标: x(0~1), y(0~1). 中心是 (0.5, 0.5)
            // atan2 返回 -PI 到 PI
            return Math.atan2(y - 0.5, x - 0.5);
        }

        const hands = new Hands({locateFile: (file) => `https://npm.elemecdn.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        hands.onResults((results) => {
            document.getElementById('loading').style.display = 'none';
            
            const handsDetected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;

            if (handsDetected) {
                const lm = results.multiHandLandmarks[0];
                const fingerTip = lm[8]; // 食指尖
                
                // 1. 获取当前食指角度
                const currentAngle = getAngle(fingerTip.x, fingerTip.y);
                
                // 2. 计算角度差 (Delta)
                if (lastAngle !== null) {
                    let delta = currentAngle - lastAngle;
                    
                    // 处理跨越 180度/-180度 的边界情况
                    if (delta > Math.PI) delta -= Math.PI * 2;
                    if (delta < -Math.PI) delta += Math.PI * 2;
                    
                    // 阈值过滤，防止手抖
                    if (Math.abs(delta) < 0.5) {
                        // 累积旋转量
                        // 注意：镜像模式下，顺时针画圈 数值可能是正也可能是负，取决于坐标系
                        // 这里我们取 delta 的符号。如果在屏幕上顺时针画，delta 通常为正（取决于atan2方向）
                        // 让我们简单点：只要动了，就增加能量，不管顺逆
                        // 或者：为了真实感，必须顺时针。
                        
                        // 在 WebGL 坐标系中 (Y向下)，顺时针会导致 delta > 0
                        // 让我们设定：顺时针 = 开门，逆时针 = 关门
                        portalState.rotationProgress += delta * 1.5; // 1.5倍增益
                    }
                }
                
                lastAngle = currentAngle;

                // 3. 限制范围 [0, 2PI * 2] (转两圈全开)
                const MAX_ROTATION = Math.PI * 4; // 需要转2圈才能开到最大
                portalState.rotationProgress = Math.max(0, Math.min(portalState.rotationProgress, MAX_ROTATION));
                
                // 4. 映射到半径
                // 0 -> 0
                // MAX -> 6
                const progressRatio = portalState.rotationProgress / MAX_ROTATION;
                portalState.targetRadius = progressRatio * portalState.maxRadius;
                
                // 5. UI 更新
                // 251 是圆环的周长
                const strokeOffset = 251 - (251 * progressRatio);
                circleRing.style.strokeDashoffset = strokeOffset;
                
                if (progressRatio < 0.1) {
                    statusText.innerText = "状态: 未激活 (请顺时针画圈)";
                    statusText.style.color = "#aaa";
                } else if (progressRatio < 0.9) {
                    statusText.innerText = `状态: 充能中 ${(progressRatio*100).toFixed(0)}%`;
                    statusText.style.color = "#f5a623";
                } else {
                    statusText.innerText = "状态: 传送门已稳定";
                    statusText.style.color = "#00ff88";
                }

            } else {
                // 手移开，重置角度锁定，但保留传送门状态一段时间，或者慢慢关闭
                lastAngle = null;
                statusText.innerText = "信号丢失 - 传送门正在闭合";
                // 自动缓慢关闭
                portalState.targetRadius = 0;
                portalState.rotationProgress *= 0.95; // 衰减
            }
        });

        // 启动
        const cameraUtils = new Camera(document.getElementById('input-video'), {
            onFrame: async () => await hands.send({image: document.getElementById('input-video')}),
            width: 640, height: 480, facingMode: 'user'
        });
        cameraUtils.start().catch(e=>log("摄像头启动失败: " + e.message));

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    </script>
</body>
</html>

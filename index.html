<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Portal (VPN Version)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #input-video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; transform: scaleX(-1); }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .spinner { width: 50px; height: 50px; border: 3px solid #333; border-top: 3px solid #f5a623; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        .loading-text { color: #f5a623; font-size: 16px; font-weight: bold; }
        .log-console { 
            margin-top: 15px; width: 80%; height: 100px; 
            font-family: monospace; font-size: 10px; color: #555; 
            border: 1px solid #333; padding: 10px; overflow-y: auto; text-align: left;
        }
        .log-error { color: #ff4444; }
        .log-success { color: #00ff88; }

        /* HUD */
        #hud { position: absolute; bottom: 50px; width: 100%; text-align: center; pointer-events: none; opacity: 0; transition: opacity 1s; }
        .title { color: #f5a623; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px rgba(245, 166, 35, 0.8); }
        .status { color: #aaa; font-size: 14px; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 15px; display: inline-block; margin-top: 5px; }

        #energy-ring { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; pointer-events: none; opacity: 0; transition: opacity 0.5s; }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">DOWNLOADING ASSETS</div>
        <div class="log-console" id="sys-log">System started...</div>
    </div>

    <div id="hud">
        <div class="title">SLING RING</div>
        <div class="status" id="status-text">Raise Index Finger</div>
    </div>

    <div id="energy-ring">
        <svg width="200" height="200" viewBox="0 0 200 200">
            <circle cx="100" cy="100" r="45" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2"/>
            <circle id="progress" cx="100" cy="100" r="45" fill="none" stroke="#f5a623" stroke-width="4" stroke-dasharray="282" stroke-dashoffset="282" transform="rotate(-90 100 100)" stroke-linecap="round"/>
        </svg>
    </div>

    <!-- Official Sources (Best for VPN users) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const logBox = document.getElementById('sys-log');
        function log(msg, type='') {
            const div = document.createElement('div');
            div.innerText = `> ${msg}`;
            if(type === 'error') div.className = 'log-error';
            if(type === 'success') div.className = 'log-success';
            logBox.appendChild(div);
            logBox.scrollTop = logBox.scrollHeight;
        }

        // --- 1. Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        const renderer = new THREE.WebGLRenderer({antialias:false});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
        const ctx = cvs.getContext('2d');
        const grd = ctx.createRadialGradient(32,32,0, 32,32,32);
        grd.addColorStop(0,'white'); grd.addColorStop(0.3,'#ffaa00'); grd.addColorStop(1,'transparent');
        ctx.fillStyle = grd; ctx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(cvs);

        const count = 3000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count*3);
        const attr = new Float32Array(count*3); // speed, angle, radius
        for(let i=0; i<count; i++) {
            pos[i*3]=999;
            attr[i*3] = 2+Math.random()*3;
            attr[i*3+1] = Math.random()*Math.PI*2;
            attr[i*3+2] = (Math.random()-0.5)*1.5;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        const sys = new THREE.Points(geo, new THREE.PointsMaterial({size:0.4, map:tex, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false}));
        scene.add(sys);

        const voidMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1,1), new THREE.MeshBasicMaterial({color:0x000, wireframe:true, transparent:true, opacity:0}));
        scene.add(voidMesh);

        let state = {r:0, tr:0, c:0};

        function animate() {
            requestAnimationFrame(animate);
            state.r += (state.tr - state.r)*0.1;
            sys.rotation.z -= 0.04;
            voidMesh.scale.setScalar(state.r*0.8);
            voidMesh.material.opacity = Math.min(1, state.r/3);
            
            const p = sys.geometry.attributes.position.array;
            for(let i=0; i<count; i++) {
                attr[i*3+1] += attr[i*3]*0.01;
                const r = state.r + attr[i*3+2];
                if(state.r > 0.1) {
                    p[i*3] = Math.cos(attr[i*3+1]) * r + (Math.random()-0.5)*0.2;
                    p[i*3+1] = Math.sin(attr[i*3+1]) * r + (Math.random()-0.5)*0.2;
                    p[i*3+2] = (Math.random()-0.5)*0.5;
                } else { p[i*3] = 999; }
            }
            sys.geometry.attributes.position.needsUpdate=true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 2. AI Init (STANDARD SOURCE) ---
        log("Connecting to jsDelivr (VPN Required)...");

        const hands = new Hands({locateFile: (file) => {
            log(`Fetch: ${file}`);
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        let isInit = false;
        
        hands.onResults(res => {
            if(!isInit) {
                isInit = true;
                log("AI Model Loaded Successfully!", 'success');
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    document.getElementById('hud').style.opacity = 1;
                    document.getElementById('energy-ring').style.opacity = 1;
                    setTimeout(()=>document.getElementById('loader').style.display='none', 500);
                }, 500);
            }

            if(res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                const ang = Math.atan2(lm[8].y-0.5, lm[8].x-0.5);
                if(window.lastAng !== undefined) {
                    let d = ang - window.lastAng;
                    if(d > Math.PI) d -= Math.PI*2;
                    if(d < -Math.PI) d += Math.PI*2;
                    if(Math.abs(d) < 0.8) state.c += d*0.8;
                }
                window.lastAng = ang;
                state.c = Math.max(0, Math.min(state.c, Math.PI*2));
                state.tr = (state.c / (Math.PI*2)) * 6;
                
                const ratio = state.c / (Math.PI*2);
                document.getElementById('progress').style.strokeDashoffset = 282 - (282*ratio);
                
                const txt = document.getElementById('status-text');
                if(ratio > 0.9) { txt.innerText = "PORTAL OPENED"; txt.style.color="#0f8"; }
                else if(ratio > 0.1) { txt.innerText = `CHARGING... ${Math.floor(ratio*100)}%`; txt.style.color="#f80"; }
                else { txt.innerText = "ROTATE CLOCKWISE"; txt.style.color="#fff"; }
            } else {
                window.lastAng = undefined;
                state.tr = 0;
                state.c *= 0.95;
                document.getElementById('status-text').innerText = "SIGNAL LOST";
                document.getElementById('status-text').style.color = "#555";
            }
        });

        // Watchdog
        setTimeout(() => {
            if(!isInit) log("TIMEOUT: Still downloading... Check VPN 'Global Mode'.", 'error');
        }, 15000);

        const vid = document.getElementById('input-video');
        const cam = new Camera(vid, {
            onFrame: async () => await hands.send({image: vid}),
            width: 640, height: 480, facingMode: 'user'
        });
        
        cam.start()
           .then(() => log("Camera started. Waiting for model download..."))
           .catch(e => log(`Camera Error: ${e.message}`, 'error'));

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>

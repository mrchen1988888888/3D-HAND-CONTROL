<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>2025 æ–°å¹´ç²’å­ç³»ç»Ÿ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #1a0505; font-family: 'Segoe UI', sans-serif; }
        
        /* èƒŒæ™¯å¾®è°ƒï¼šæ–°å¹´çº¢é»‘æ¸å˜ */
        body { background: radial-gradient(circle, #2b0a0a 0%, #000000 100%); }

        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            opacity: 0; pointer-events: none; z-index: -1; 
            transform: scaleX(-1);
        }
        
        /* é¡¶éƒ¨å¤§æ ‡é¢˜ */
        #title-display {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            font-size: 24px; font-weight: bold; color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            pointer-events: none; z-index: 90;
            text-align: center; letter-spacing: 2px;
        }

        /* åº•éƒ¨æç¤º */
        #guide-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(40, 0, 0, 0.8); border: 1px solid #ff4444;
            padding: 10px 20px; border-radius: 30px;
            color: #ffcccc; font-size: 14px;
            pointer-events: none; z-index: 90; text-align: center;
        }

        /* çŠ¶æ€æŒ‡ç¤º HUD */
        #hud-status {
            position: absolute; top: 80px; left: 20px;
            background: rgba(0, 0, 0, 0.6); border-left: 3px solid #ffd700;
            padding: 8px 15px; color: #ffd700; font-family: monospace;
            border-radius: 0 5px 5px 0; z-index: 50;
        }

        .loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #ffd700; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loading" class="loading-mask">
        <div class="spinner"></div>
        <div style="color:#ffd700; font-size: 14px;">æ­£åœ¨æ„å»º 2025 æ•°å­—å®‡å®™...</div>
    </div>
    
    <div id="title-display">HAPPY NEW YEAR 2025</div>
    <div id="hud-status">SYSTEM: READY</div>
    
    <div id="guide-panel">
        ğŸ–±ï¸ ç‚¹å‡»æ•°å­—: å•ç‹¬å±•ç¤º | ğŸ‘Œ OKæ‰‹åŠ¿: å…¨å±€å¤ä½
    </div>

    <!-- ä½¿ç”¨å›½å†…æº -->
    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. Three.js åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a0505, 0.002);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // å…‰ç…§ (ä¸ºäº†è®©é‡‘è‰²ç²’å­æ›´æœ‰è´¨æ„Ÿ)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // --- 2. æ•°å­—ç²’å­ç”Ÿæˆå™¨ ---
        // æˆ‘ä»¬ä¸åŠ è½½å­—ä½“æ–‡ä»¶ï¼Œè€Œæ˜¯ç”¨ Canvas ç”»å‡ºæ•°å­—ç„¶åæå–åƒç´ åæ ‡
        // è¿™æ ·é€Ÿåº¦æœ€å¿«ï¼Œå…¼å®¹æ€§æœ€å¥½

        const digitMeshes = []; // å­˜å‚¨ 4 ä¸ªæ•°å­—çš„ Mesh
        const digitData = [
            { char: "2", x: -9 },
            { char: "0", x: -3 },
            { char: "2", x: 3 },
            { char: "5", x: 9 }
        ];

        // ç›®æ ‡ä½ç½®çŠ¶æ€ç®¡ç†
        const targets = {
            default: [], // é»˜è®¤ä½ç½® [posVector, posVector, ...]
            center: new THREE.Vector3(0, 0, 10) // é€‰ä¸­æ—¶çš„ä¸­å¿ƒä½ç½®
        };

        // å½“å‰çŠ¶æ€
        let activeDigitIndex = -1; // -1 è¡¨ç¤ºæ˜¾ç¤ºæ‰€æœ‰ï¼Œ0-3 è¡¨ç¤ºæ˜¾ç¤ºç‰¹å®šæ•°å­—

        function createTextParticles(text, offsetX) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 200;
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.font = 'bold 160px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 100);

            const imgData = ctx.getImageData(0, 0, 200, 200);
            const positions = [];
            
            // æ‰«æåƒç´ 
            for (let y = 0; y < 200; y += 4) { // æ­¥é•¿å†³å®šç²’å­å¯†åº¦
                for (let x = 0; x < 200; x += 4) {
                    const index = (y * 200 + x) * 4;
                    if (imgData.data[index] > 128) { // å¦‚æœæœ‰åƒç´ 
                        // è½¬æ¢åæ ‡: Canvas(0,0åœ¨å·¦ä¸Š) -> Three(0,0åœ¨ä¸­å¿ƒ)
                        const pX = (x - 100) * 0.1;
                        const pY = (100 - y) * 0.1;
                        // å¢åŠ ä¸€ç‚¹åšåº¦ Z
                        const pZ = (Math.random() - 0.5) * 2;
                        positions.push(pX, pY, pZ);
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            // æè´¨ï¼šé‡‘è‰²ç²’å­
            const material = new THREE.PointsMaterial({
                color: 0xffd700, // Gold
                size: 0.25,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });

            const mesh = new THREE.Points(geometry, material);
            // è®¾ç½®åˆå§‹ä½ç½®
            mesh.position.set(offsetX, 0, 0);
            
            // å­˜å‚¨é»˜è®¤ä½ç½®ä»¥ä¾¿å¤ä½
            mesh.userData = {
                originalPos: new THREE.Vector3(offsetX, 0, 0),
                originalScale: 1.0,
                velocity: new THREE.Vector3(0,0,0) // ç”¨äºåŠ¨ç”»æ’å€¼
            };
            
            scene.add(mesh);
            return mesh;
        }

        // ç”Ÿæˆ "2025"
        digitData.forEach((d, i) => {
            const mesh = createTextParticles(d.char, d.x);
            digitMeshes.push(mesh);
            targets.default.push(mesh.userData.originalPos);
        });

        // --- 3. é¼ æ ‡/ç‚¹å‡» äº¤äº’é€»è¾‘ ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // å¢åŠ  Raycaster çš„é˜ˆå€¼ï¼Œè®©ç²’å­æ›´å®¹æ˜“è¢«ç‚¹ä¸­
        raycaster.params.Points.threshold = 1.0;

        window.addEventListener('click', onMouseClick);
        // å…¼å®¹æ‰‹æœºè§¦æ‘¸
        window.addEventListener('touchstart', (e) => {
            e.preventDefault(); // é˜²æ­¢åŒå‡»ç¼©æ”¾
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            checkIntersection();
        }, {passive: false});

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            checkIntersection();
        }

        function checkIntersection() {
            // å¦‚æœå·²ç»åœ¨å±•ç¤ºå•ä¸ªæ•°å­—ï¼Œç‚¹å‡»ç©ºç™½å¤„ä¸ä¸€å®šå¤ä½ï¼Œè¿™é‡Œè®¾å®šä¸ºç‚¹å‡»æ‰åˆ‡æ¢
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(digitMeshes);

            if (intersects.length > 0) {
                // æ‰¾åˆ°äº†è¢«ç‚¹å‡»çš„æ•°å­—å¯¹è±¡
                const selectedObject = intersects[0].object;
                const index = digitMeshes.indexOf(selectedObject);
                
                if (index !== -1 && index !== activeDigitIndex) {
                    focusOnDigit(index);
                }
            } else {
                // ç‚¹å‡»ç©ºç™½å¤„ï¼Œæš‚ä¸å¤„ç†ï¼Œä¿ç•™æ‰‹åŠ¿å¤ä½åŠŸèƒ½
                // å¦‚æœä½ æƒ³ç‚¹å‡»ç©ºç™½å¤„å¤ä½ï¼Œå¯ä»¥è§£å¼€ä¸‹é¢æ³¨é‡Š
                // resetAll();
            }
        }

        function focusOnDigit(index) {
            activeDigitIndex = index;
            document.getElementById('hud-status').innerText = `SELECTED: ${digitData[index].char}`;
            document.getElementById('hud-status').style.color = "#ff4444";
        }

        function resetAll() {
            if (activeDigitIndex === -1) return; // å·²ç»æ˜¯å¤ä½çŠ¶æ€
            activeDigitIndex = -1;
            document.getElementById('hud-status').innerText = "SYSTEM: READY";
            document.getElementById('hud-status').style.color = "#ffd700";
        }

        // --- 4. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            digitMeshes.forEach((mesh, i) => {
                // ç²’å­è‡ªèº«æ—‹è½¬ç‰¹æ•ˆ
                mesh.rotation.y += 0.005;
                mesh.rotation.x = Math.sin(Date.now() * 0.001 + i) * 0.1;

                // ç›®æ ‡çŠ¶æ€è®¡ç®—
                let targetPos, targetScale, targetOpacity;

                if (activeDigitIndex === -1) {
                    // --- é»˜è®¤çŠ¶æ€ï¼šæ˜¾ç¤ºæ‰€æœ‰ ---
                    targetPos = mesh.userData.originalPos;
                    targetScale = 1.0;
                    targetOpacity = 0.9;
                } else {
                    // --- é€‰ä¸­çŠ¶æ€ ---
                    if (i === activeDigitIndex) {
                        // é€‰ä¸­çš„æ•°å­—ï¼šé£åˆ°ä¸­é—´ï¼Œå˜å¤§
                        targetPos = targets.center;
                        targetScale = 2.0;
                        targetOpacity = 1.0;
                    } else {
                        // å…¶ä»–æ•°å­—ï¼šé£æ•£/éšè—
                        // æˆ‘ä»¬å¯ä»¥è®©å®ƒä»¬å‘å››å‘¨é£èµ°ï¼Œæˆ–è€…ç›´æ¥åŸåœ°æ¶ˆå¤±
                        targetPos = mesh.userData.originalPos.clone().multiplyScalar(3); // å‘å¤–é£
                        targetScale = 0.1;
                        targetOpacity = 0.0;
                    }
                }

                // ç®€å•çš„ Lerp æ’å€¼åŠ¨ç”»
                mesh.position.lerp(targetPos, 0.08);
                // ç¼©æ”¾æ¨¡æ‹Ÿ (Points æ²¡æœ‰ scale å±æ€§ï¼Œæˆ‘ä»¬é€šè¿‡ä¿®æ”¹ä½ç½®é—´è·æ¨¡æ‹Ÿï¼Œæˆ–è€…ç®€å•ä¿®æ”¹æè´¨ size)
                // è¿™é‡Œæˆ‘ä»¬ç›´æ¥ä¿®æ”¹å¯¹è±¡ scale
                const s = mesh.scale.x + (targetScale - mesh.scale.x) * 0.08;
                mesh.scale.set(s, s, s);
                
                mesh.material.opacity += (targetOpacity - mesh.material.opacity) * 0.1;
                mesh.material.size = (targetScale > 1.5 ? 0.35 : 0.25); // æ”¾å¤§æ—¶ç²’å­ä¹Ÿå˜å¤§ç‚¹
            });

            renderer.render(scene, camera);
        }
        animate();

        // --- 5. æ‰‹åŠ¿è¯†åˆ« (OKå¤ä½) ---
        const videoElement = document.getElementById('input-video');
        const loadingDiv = document.getElementById('loading');
        let lastOkTime = 0;

        const hands = new Hands({locateFile: (file) => `https://npm.elemecdn.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        function isOK(lm) {
            // æ‹‡æŒ‡(4)å’Œé£ŸæŒ‡(8)å°–ç«¯è·ç¦»å¾ˆè¿‘
            const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            const handSize = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
            const isPinch = (pinchDist / handSize) < 0.25;

            // å…¶ä»–ä¸‰æŒ‡å¿…é¡»æ˜¯ä¼¸ç›´çš„ (æŒ‡å°– y < æŒ‡æ ¹ y) 
            // æ³¨æ„ï¼šMediaPipe yè½´å‘ä¸‹ï¼Œæ‰€ä»¥æ•°å€¼å°æ˜¯ä¸Šæ–¹
            // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åªæ£€æµ‹ä¸­æŒ‡(12)ã€æ— åæŒ‡(16)ã€å°æŒ‡(20)æ˜¯å¦é«˜äºæ‹‡æŒ‡è·Ÿ(2)
            const othersUp = lm[12].y < lm[2].y && lm[16].y < lm[2].y && lm[20].y < lm[2].y;
            
            return isPinch && othersUp;
        }

        hands.onResults((results) => {
            if(loadingDiv.style.display !== 'none') loadingDiv.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // æ£€æµ‹ OK æ‰‹åŠ¿
                if (isOK(lm)) {
                    const now = Date.now();
                    // é˜²æŠ– 1ç§’
                    if (now - lastOkTime > 1000) {
                        if (activeDigitIndex !== -1) {
                            // åªæœ‰åœ¨éé»˜è®¤çŠ¶æ€ä¸‹ï¼ŒOK æ‰è§¦å‘å¤ä½
                            resetAll();
                            
                            // ç®€å•çš„è§†è§‰åé¦ˆ
                            const hud = document.getElementById('hud-status');
                            hud.innerText = "ğŸ‘Œ RESET DETECTED";
                            hud.style.color = "#00ff88";
                            setTimeout(() => {
                                hud.innerText = "SYSTEM: READY";
                                hud.style.color = "#ffd700";
                            }, 1000);
                        }
                        lastOkTime = now;
                    }
                }
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 480, height: 360, facingMode: 'user'
        });
        cameraUtils.start();

        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        });

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Strange: Local Spin</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        
        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            opacity: 0; pointer-events: none; z-index: -1; 
            transform: scaleX(-1);
        }

        /* LOG BOX */
        #console-container {
            position: absolute; top: 10px; left: 10px; width: 250px; 
            background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff88;
            padding: 10px; z-index: 100; font-size: 10px; color: #00ff88;
            pointer-events: none;
        }

        /* TRACKING DEBUGGERS */
        .tracker-dot {
            position: absolute; width: 15px; height: 15px; border-radius: 50%;
            pointer-events: none; z-index: 50; transform: translate(-50%, -50%);
            display: none;
        }
        #tip-tracker { background: red; border: 2px solid white; }   /* Index Finger */
        #wrist-tracker { background: blue; border: 2px solid white; } /* Wrist */

        /* HUD */
        #hud-layer {
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 10;
        }
        .spell-status {
            color: #fff; font-size: 16px; background: rgba(0,0,0,0.7); 
            padding: 10px 25px; border-radius: 20px; border: 1px solid #ffaa00;
            font-weight: bold;
        }

        /* Spinner */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 90;
            display: flex; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid #333; 
            border-top: 3px solid #00ff88; border-radius: 50%; 
            animation: spin 1s infinite linear;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="console-container">
        <div>SYSTEM STATUS: ONLINE</div>
        <div id="math-debug" style="color:white; margin-top:5px;">Waiting for hand...</div>
    </div>

    <!-- Visual Trackers to verify math -->
    <div id="tip-tracker" class="tracker-dot"></div>
    <div id="wrist-tracker" class="tracker-dot"></div>

    <div id="loader"><div class="spinner"></div></div>

    <div id="hud-layer">
        <div class="spell-status" id="status-text">INITIALIZING...</div>
    </div>

    <!-- SOURCES -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

    <script>
        const debugBox = document.getElementById('math-debug');

        // --- 1. VISUAL ENGINE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.04);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 14;
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Texture
        const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
        const ctx = cvs.getContext('2d');
        const gr = ctx.createRadialGradient(16,16,0,16,16,16);
        gr.addColorStop(0,'white'); gr.addColorStop(0.3,'#ffaa00'); gr.addColorStop(1,'transparent');
        ctx.fillStyle=gr; ctx.fillRect(0,0,32,32);
        const tex = new THREE.CanvasTexture(cvs);

        // Particles
        const COUNT = 5000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(COUNT*3);
        const vel = new Float32Array(COUNT*3);
        const life = new Float32Array(COUNT);
        
        for(let i=0; i<COUNT; i++) { pos[i*3]=9999; life[i]=0; }
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        const mat = new THREE.PointsMaterial({size:0.4, map:tex, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, color:0xffaa00});
        const sys = new THREE.Points(geo, mat);
        scene.add(sys);

        // The Void
        const voidGeo = new THREE.CircleGeometry(1, 32);
        const voidMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const voidMesh = new THREE.Mesh(voidGeo, voidMat);
        voidMesh.position.z = 0.1;
        scene.add(voidMesh);

        // State
        const State = { r:0, tr:0, charge:0 };

        function animate() {
            requestAnimationFrame(animate);
            State.r += (State.tr - State.r)*0.1;
            sys.rotation.z -= 0.05;
            
            // Void Animation
            voidMesh.scale.setScalar(State.r * 0.9);

            const p = geo.attributes.position.array;
            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                life[i] -= 0.02 + Math.random()*0.01;
                
                if(life[i] <= 0) {
                    if(State.r > 0.2) {
                        const a = Math.random()*Math.PI*2;
                        const r = State.r + (Math.random()-0.5)*0.5;
                        p[idx] = Math.cos(a)*r;
                        p[idx+1] = Math.sin(a)*r;
                        p[idx+2] = (Math.random()-0.5);
                        
                        const s = 0.1 + Math.random()*0.2;
                        vel[idx] = -Math.sin(a)*s;
                        vel[idx+1] = Math.cos(a)*s;
                        vel[idx+2] = (Math.random()-0.5)*0.05;
                        life[i] = 1;
                    } else { p[idx] = 9999; }
                } else {
                    p[idx] += vel[idx];
                    p[idx+1] += vel[idx+1];
                    p[idx+2] += vel[idx+2];
                }
            }
            geo.attributes.position.needsUpdate=true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 2. AI LOGIC (FIXED) ---
        const videoEl = document.getElementById('input-video');
        const statusText = document.getElementById('status-text');
        
        // Debug Trackers
        const tipDot = document.getElementById('tip-tracker');
        const wristDot = document.getElementById('wrist-tracker');

        let lastAng = null;
        let lossTimer = null;

        const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        let isLoaded = false;
        hands.onResults(res => {
            if(!isLoaded) {
                isLoaded = true;
                document.getElementById('loader').style.opacity = 0;
                setTimeout(()=>document.getElementById('loader').style.display='none', 500);
            }

            if(res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                
                // --- NEW MATH: Local Rotation ---
                // We calculate angle between WRIST (0) and INDEX TIP (8)
                const wrist = lm[0];
                const tip = lm[8];

                // Convert to screen coordinates for dots
                // Flip X because video is mirrored
                const tipX = (1 - tip.x) * window.innerWidth;
                const tipY = tip.y * window.innerHeight;
                const wristX = (1 - wrist.x) * window.innerWidth;
                const wristY = wrist.y * window.innerHeight;

                // Move dots
                tipDot.style.display = 'block';
                wristDot.style.display = 'block';
                tipDot.style.left = tipX + 'px';
                tipDot.style.top = tipY + 'px';
                wristDot.style.left = wristX + 'px';
                wristDot.style.top = wristY + 'px';

                // Calculate Angle relative to WRIST
                // dx, dy
                const dx = tipX - wristX;
                const dy = tipY - wristY;
                const ang = Math.atan2(dy, dx);

                if(lastAng !== null) {
                    let d = ang - lastAng;
                    // Handle wrap around PI
                    if(d > Math.PI) d -= Math.PI*2;
                    if(d < -Math.PI) d += Math.PI*2;
                    
                    // Show delta in debug box
                    debugBox.innerText = `Delta: ${d.toFixed(2)}`;

                    // Threshold: Ignore tiny jitters, accept real movement
                    if(Math.abs(d) > 0.05 && Math.abs(d) < 1.5) { 
                        State.charge += Math.abs(d) * 15.0; // Boosted sensitivity
                    }
                }
                lastAng = ang;
                State.charge = Math.min(State.charge, 100);
                State.tr = (State.charge / 100) * 6;

                // Text Feedback
                if(State.charge > 15) {
                    statusText.innerText = `OPENING... ${Math.floor(State.charge)}%`;
                    statusText.style.color = "#ffaa00";
                } else {
                    statusText.innerText = "SPIN FINGER AROUND WRIST";
                    statusText.style.color = "#00ff88";
                }

                if(lossTimer) clearTimeout(lossTimer);

            } else {
                tipDot.style.display = 'none';
                wristDot.style.display = 'none';
                debugBox.innerText = "No Hand";
                
                if(!lossTimer) {
                    lossTimer = setTimeout(() => {
                        lastAng = null;
                        State.charge *= 0.9;
                        if(State.charge < 1) State.charge = 0;
                        State.tr = 0;
                        statusText.innerText = "SIGNAL LOST";
                        statusText.style.color = "#555";
                    }, 200);
                }
            }
        });

        const cam = new Camera(videoEl, {
            onFrame: async () => await hands.send({image: videoEl}),
            width: 640, height: 480, facingMode: 'user'
        });
        cam.start();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>

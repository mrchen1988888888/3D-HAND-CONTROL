<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>å¥‡å¼‚åšå£«ä¼ é€é—¨(æé€Ÿç‰ˆ)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #input-video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; transform: scaleX(-1); }
        
        #hud { position: absolute; bottom: 50px; width: 100%; text-align: center; z-index: 10; pointer-events: none; }
        .title { color: #f5a623; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px rgba(245, 166, 35, 0.8); margin-bottom: 10px; }
        .status { color: #ddd; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px; display: inline-block; font-size: 14px; }

        #energy-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; pointer-events: none; opacity: 0.8; z-index: 5; }
        
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        .log-box { color: #00ff88; font-family: monospace; font-size: 12px; margin-top: 20px; text-align: center; max-width: 90%; }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loading">
        <div style="color:#f5a623; font-size: 20px; font-weight:bold;">âš¡ æ­£åœ¨æ¥å…¥é­”æ³•ç½‘ç»œ...</div>
        <div class="log-box" id="debug-log">åˆå§‹åŒ–ä¸­...</div>
    </div>

    <div id="hud">
        <div class="title">SLING RING</div>
        <div class="status" id="status-text">ä¸¾èµ·é£ŸæŒ‡ é¡ºæ—¶é’ˆç”»åœˆ</div>
    </div>

    <div id="energy-container">
        <svg width="200" height="200" viewBox="0 0 200 200">
            <circle cx="100" cy="100" r="40" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2" />
            <circle id="ring" cx="100" cy="100" r="40" fill="none" stroke="#f5a623" stroke-width="4" stroke-dasharray="251" stroke-dashoffset="251" transform="rotate(-90 100 100)" stroke-linecap="round" />
        </svg>
    </div>

    <!-- 1. ä½¿ç”¨å›½å†… Eleme CDN åŠ è½½æ ¸å¿ƒåº“ -->
    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js"></script>

    <script>
        const logEl = document.getElementById('debug-log');
        function log(msg) { logEl.innerHTML = msg; console.log(msg); }

        // --- Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        const renderer = new THREE.WebGLRenderer({antialias:false});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // ç«èŠ±çº¹ç†
        const canvas = document.createElement('canvas');
        canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32,32,0,32,32,32);
        grad.addColorStop(0,'white'); grad.addColorStop(0.2,'#ffc800'); grad.addColorStop(0.4,'#ff6400'); grad.addColorStop(1,'transparent');
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        const texture = new THREE.CanvasTexture(canvas);

        // ç²’å­ç³»ç»Ÿ
        const count = 2500;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count*3);
        const speeds = new Float32Array(count);
        const angles = new Float32Array(count);
        const radii = new Float32Array(count);
        
        for(let i=0; i<count; i++) {
            angles[i] = Math.random()*Math.PI*2;
            radii[i] = (Math.random()-0.5)*1.5;
            speeds[i] = 2+Math.random()*3;
            pos[i*3]=999; pos[i*3+1]=999; pos[i*3+2]=0;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        const mat = new THREE.PointsMaterial({size:0.4, map:texture, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false});
        const ring = new THREE.Points(geo, mat);
        scene.add(ring);

        const mirror = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1,2),
            new THREE.MeshBasicMaterial({color:0x001133, wireframe:true, transparent:true, opacity:0})
        );
        scene.add(mirror);

        let state = { r:0, targetR:0, progress:0 };

        function animate() {
            requestAnimationFrame(animate);
            state.r += (state.targetR - state.r)*0.08;
            mirror.scale.setScalar(state.r*0.9);
            mirror.material.opacity = Math.min(1, state.r/3);
            mirror.rotation.y += 0.01;
            
            ring.rotation.z -= 0.03;
            const p = ring.geometry.attributes.position.array;
            for(let i=0; i<count; i++) {
                angles[i] += speeds[i]*0.01;
                const r = state.r + radii[i];
                if(state.r > 0.1) {
                    p[i*3] = Math.cos(angles[i])*r + (Math.random()-0.5)*0.15;
                    p[i*3+1] = Math.sin(angles[i])*r + (Math.random()-0.5)*0.15;
                    p[i*3+2] = (Math.random()-0.5);
                } else { p[i*3]=999; }
            }
            ring.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- MediaPipe (æé€Ÿç‰ˆé…ç½®) ---
        log("ğŸš€ æ­£åœ¨ä»å›½å†…é•œåƒä¸‹è½½ AI æ¨¡å‹...");
        
        const video = document.getElementById('input-video');
        const uiRing = document.getElementById('ring');
        const uiText = document.getElementById('status-text');
        let lastAng = null;

        // 2. å¼ºåˆ¶ä½¿ç”¨ Eleme CDN åŠ è½½æ¨¡å‹æ–‡ä»¶
        const hands = new Hands({locateFile: (file) => {
            return `https://npm.elemecdn.com/@mediapipe/hands/${file}`;
        }});

        // 3. ä½¿ç”¨ Lite æ¨¡å‹ (0) åŠ é€ŸåŠ è½½å’Œè¿è¡Œ
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 0, // 0=Lite (æœ€å¿«), 1=Full
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });

        let loaded = false;
        hands.onResults(res => {
            if(!loaded) {
                loaded = true;
                document.getElementById('loading').style.display = 'none';
            }
            if(res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                const tip = lm[8];
                const ang = Math.atan2(tip.y-0.5, tip.x-0.5);
                
                if(lastAng !== null) {
                    let d = ang - lastAng;
                    if(d > Math.PI) d -= Math.PI*2;
                    if(d < -Math.PI) d += Math.PI*2;
                    if(Math.abs(d) < 0.5) state.progress += d * 2.0;
                }
                lastAng = ang;
                state.progress = Math.max(0, Math.min(state.progress, Math.PI*4));
                const ratio = state.progress / (Math.PI*4);
                state.targetR = ratio * 6;
                uiRing.style.strokeDashoffset = 251 - (251*ratio);
                
                if(ratio > 0.8) { uiText.innerText = "ä¼ é€é—¨å·²å¼€å¯"; uiText.style.color="#0f8"; }
                else if(ratio > 0.1) { uiText.innerText = `å……èƒ½ ${(ratio*100).toFixed(0)}%`; uiText.style.color="#f80"; }
                else { uiText.innerText = "é¡ºæ—¶é’ˆç”»åœˆ"; uiText.style.color="#ddd"; }
            } else {
                lastAng = null;
                state.targetR = 0;
                state.progress *= 0.9;
                uiText.innerText = "ä¿¡å·ä¸¢å¤±"; uiText.style.color="#555";
            }
        });

        const cam = new Camera(video, {
            onFrame: async () => await hands.send({image: video}),
            width: 640, height: 480, facingMode: 'user'
        });
        
        cam.start()
           .then(() => log("âœ… æ‘„åƒå¤´å°±ç»ªï¼Œæ­£åœ¨ä¸‹è½½æ¨¡å‹..."))
           .catch(e => log(`âŒ æ‘„åƒå¤´é”™è¯¯: ${e.message}<br>è¯·å…è®¸æƒé™å¹¶ä½¿ç”¨HTTPS`));

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
